<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>transformers | Shreyansh Singh</title>
    <link>https://shreyansh26.github.io/tags/transformers/</link>
      <atom:link href="https://shreyansh26.github.io/tags/transformers/index.xml" rel="self" type="application/rss+xml" />
    <description>transformers</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© Shreyansh Singh 2023</copyright><lastBuildDate>Sun, 28 May 2023 19:49:27 +0530</lastBuildDate>
    <image>
      <url>https://shreyansh26.github.io/img/Shreyansh.jpg</url>
      <title>transformers</title>
      <link>https://shreyansh26.github.io/tags/transformers/</link>
    </image>
    
    <item>
      <title>Paper Summary #9 - Sophia: A Scalable Stochastic Second-order Optimizer for Language Model Pre-training</title>
      <link>https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/</link>
      <pubDate>Sun, 28 May 2023 19:49:27 +0530</pubDate>
      <guid>https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Paper&lt;/strong&gt;: Sophia: A Scalable Stochastic Second-order Optimizer for Language Model Pre-training&lt;br&gt;
&lt;strong&gt;Link&lt;/strong&gt;: &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;Authors&lt;/strong&gt;: Hong Liu, Zhiyuan Li, David Hall, Percy Liang, Tengyu Ma&lt;br&gt;
&lt;strong&gt;Code&lt;/strong&gt;: &lt;a href=&#34;https://github.com/Liuhong99/Sophia&#34;&gt;https://github.com/Liuhong99/Sophia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I have also released an annotated version of the paper. If you are interested, you can find it &lt;a href=&#34;https://github.com/shreyansh26/Annotated-ML-Papers/blob/main/ML%20Theory/Sophia%20-%20A%20Scalable%20Stochastic%20Second-order%20Optimizer%20for%20Language%20Model%20Pretraining.pdf&#34;&gt;here&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Sophia is probably one of the most interesting papers I have read recently and I really liked how well it was written. This post is basically the notes that I had made while reading the paper, which is why it is not exactly a blog post and most of it is verbatim copied from the paper. But since there are a lot of optimization-theory related concepts which have been mentioned in the paper, I have tried to add my own set of references which I have read in the past that helped me understand the paper better. Hopefully it helps someone!&lt;/p&gt;
&lt;h1 id=&#34;overview&#34;&gt;Overview&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The goal of this work is to propose a new optimizer for pre-training LLMs that can improve pre-training efficiency with a faster optimizer, which either reduces the time and cost to achieve the same pre-training loss, or alternatively achieves better pre-training loss with the same budget.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adam and its variants have become the somewhat default optimizers which are used in LLM pretraining.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Designing fast optimizers for LLMs is challenging because -&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The benefit of the first-order pre-conditioner (the $1/\sqrt{v_t}$ factor) in Adam is still not well understood.&lt;/li&gt;
&lt;li&gt;The choice of pre-conditioners is constrained because we can only afford light-weight options whose overhead can be offset by the speed-up in the number of iterations.&lt;/li&gt;
&lt;li&gt;Among the recent works on light-weight gradient-based pre-conditioners, &lt;a href=&#34;https://arxiv.org/abs/2302.06675&#34;&gt;Lion&lt;/a&gt; stood out as it is substantially faster than Adam on vision Transformers and diffusion models but only achieves limited speed-up on LLMs.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;This paper introduces Sophia, &lt;strong&gt;S&lt;/strong&gt;econd-&lt;strong&gt;o&lt;/strong&gt;rder Cli&lt;strong&gt;p&lt;/strong&gt;ped Stoc&lt;strong&gt;h&lt;/strong&gt;ast&lt;strong&gt;i&lt;/strong&gt;c Optimiz&lt;strong&gt;a&lt;/strong&gt;tion, a light-weight second-order optimizer that uses an inexpensive stochastic estimate of the diagonal of the Hessian as a pre-conditioner and a clipping mechanism to control the worst-case update size.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Key Results -&lt;/p&gt;
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/src89abpL3fgu-saaWEWVmLmuigWxwsWvQde9cntTK9DuGVFZSBYpNo1FC2KM9y6uyf1VOaPs_ouZyxF-HP9umwC6xem71xx7460IH1MkEGevVn-IXj1j-I3MiOnNBto.png)  --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig1.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig1.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Sophia achieves the same validation pre-training loss with 50% fewer number of steps than Adam.&lt;/li&gt;
&lt;li&gt;Sophia maintains almost the memory and average time per step and therefore the speedup also translates to 50% less total compute and 50% less wall-clock time.&lt;/li&gt;
&lt;li&gt;The scaling law based on model size from 125M to 770M is in favor of Sophia over Adam - the gap between Sophia and Adam with 100K steps increases as the model size increases. Sophia on a 540M-parameter model with 100K steps gives the same validation loss as Adam on a 770M-parameter model with 100K steps.&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Checking the performance and scalability of this optimizer for pre-training much larger model sizes would (although expensive) be interesting to see.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sophia estimates the diagonal entries of the Hessian of the loss using a mini-batch of examples every $k$ steps ($k=10$ in the paper).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The paper considers two options for diagonal Hessian estimators -&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hutchinson’s unbiased estimator -  an unbiased estimator that uses a Hessian-vector product with the same run-time as a mini-batch gradient up to a constant factor&lt;/li&gt;
&lt;li&gt;Gauss-Newton-Bartlett (GNB) estimator -  a biased estimator that uses one mini-batch gradient calculated with resampled labels.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Both the estimators introduce only a 5% overhead per step (on average).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sophia updates the parameter with an exponential moving average (EMA) of the gradient divided by the EMA of the diagonal Hessian estimate, subsequently clipped by a scalar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Due to the Hessian-based pre-conditioner, Sophia adapts more efficiently, than Adam does, to the heterogeneous curvatures in different parameter dimensions, which can often occur in the landscape of LLMs losses and cause instability or slowdown.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In terms of the loss landscape, Sophia has a more aggressive pre-conditioner than Adam - Sophia applies a stronger penalization to updates in sharp dimensions (where the Hessian is large) than the flat dimensions (where the Hessian is small), &lt;b&gt;ensuring a uniform &lt;i&gt;&lt;ins&gt;loss decrease&lt;/ins&gt;&lt;/i&gt; across all parameter dimensions&lt;/b&gt;.  In contrast, &lt;strong&gt;Adam’s updates are mostly uniform across all parameter dimensions, leading to a slower loss decrease in flat dimensions&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sophia’s clipping mechanism controls the worst-case size of the updates in all directions, safeguarding against the negative impact of inaccurate Hessian estimates, rapid Hessian changes over time, and non-convex landscape.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;motivations&#34;&gt;Motivations&lt;/h1&gt;
&lt;h2 id=&#34;heterogeneous-curvatures&#34;&gt;Heterogeneous Curvatures&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Loss functions in modern deep learning problems often have different curvatures across different parameter dimensions.&lt;/li&gt;
&lt;li&gt;The paper demonstrates the limitations of Adam and Gradient Descent by considering a two dimensional loss function - $L(\theta_{[1]},\theta_{[2]}) = L_1(\theta_{[1]}) + L_2(\theta_{[2]})$ where $$L_{1}(\theta_{[1]}) = 8(\theta_{[1]} - 1)^2(1.3\theta_{[1]}^2 + 2\theta_{[1]} + 1)$$ $$L_2(\theta_{[2]}) = 1/2 (\theta_{[2]} - 4)^2$$&lt;/li&gt;
&lt;li&gt;Here $L_1$ is much sharper than $L_2$.&lt;/li&gt;
&lt;li&gt;Another optimizer, SignGD is also compared which is quite old but can be understood as a simplified version of Adam, which does not involve taking the EMA for gradients and second moments of the gradients. The update then simplifies to - $\eta \cdot \nabla L(\theta)/|\nabla L(\theta)| = \eta\cdot \textup{sign}(\nabla L(\theta))$.&lt;/li&gt;
&lt;/ul&gt;
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/LrMmz7R-DKnsQqGyXsWf1HCZGZcyB_TtnGuJk8HcpijBAmdkt7zYi-BKvLQrTx2Wwb7fYqaS7dUv2Iw_Th3y4vE6ymaNdnVVP1h9xEufWJmPJqFqqyx3Sp9NFy41jOF_.png) --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig2.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig2.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;limitations-of-gd-and-signgd-adam&#34;&gt;Limitations of GD and SignGD (Adam)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The optimal learning rate of Gradient Descent should be proportional to the inverse of the curvature, i.e., the Hessian/second derivative at the local minimum. A good set of resources to understand this in detail are some notes from University of Toronto &lt;a href=&#34;https://www.cs.toronto.edu/~rgrosse/courses/csc2541_2022/readings/L01_intro.pdf&#34;&gt;Section 2.2&lt;/a&gt; and &lt;a href=&#34;https://www.cs.toronto.edu/~rgrosse/courses/csc2541_2022/readings/L02_Taylor_approximations.pdf&#34;&gt;Section 4.1&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;So, if the curvatures of $L_1$ and $L_2$ at the local minima are $h_1$ and $h_2$ respectively (and thus $h_1 &amp;gt; h_2$ ). So the largest shared learning rate can only be $1/h_1$. Hence, the convergence in $\theta_{[2]}$ dimension is slow as also shown in the figure above.
&lt;br&gt;
&lt;br&gt;&lt;/li&gt;
&lt;li&gt;The update size of SignGD is the learning rate $\eta$ in all dimensions. Hence, intuitively, the same update size translates to less progress in decreasing the loss in the flat direction than in the sharp direction. In the yellow curve in the above figure, the progress of SignGD in the flat dimension $\theta_{[2]}$ is slow and along $\theta_{[1]}$, theiterate quickly travels to the valley in the first three steps and then starts to bounce.  To fully converge in the sharp dimension, the learning rate $\eta$ needs to decay to $0$, which will exacerbate the slow convergence in the flat dimension $θ_{[2]}$. The trajectory of Adam is similar to SignGD and shown by the red curve in the figure.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;The behavior of SignGD and Adam above indicates that a more aggressive pre-conditioning is needed - sharp dimensions should have relatively smaller updates than flat dimensions so that the decrease of loss is equalized in all dimensions.&lt;/li&gt;
&lt;li&gt;Prior work on second order optimization suggest that the optimal pre-conditioner is the Hessian which captures the curvature on each dimension.&lt;/li&gt;
&lt;li&gt;The Newton’s method, does something similar - the update is the gradient divided by the Hessian in each dimension.$$\theta_{[1]} \leftarrow \theta_{[1]} - \eta \cdot L&amp;rsquo;_1(\theta_{[1]}) / h_1\ \ \textup{and}\ \ \theta_{[2]} \leftarrow \theta_{[2]} - \eta \cdot L&amp;rsquo;_2(\theta_{[2]})/ h_2$$ 
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;limitations-of-newtons-method&#34;&gt;Limitations of Newton&amp;rsquo;s method&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Vanilla Newton’s method could converge to a global maximum when the local curvature is negative.&lt;/li&gt;
&lt;li&gt;As shown in the blue curve in the figure,   Newton’s method quickly converges to a saddle point instead of a local minimum.&lt;/li&gt;
&lt;li&gt;Since the curvature may change rapidly along a trajectory, the second order information can often become unreliable.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;Sophia addresses this by considering only pre-conditioners that capture positive curvature, and introduce a per-coordinate clipping mechanism to mitigate the rapid change of Hessian. Applying those changes results in the following update - $$\theta_{[1]} \leftarrow \theta_{[1]} - \eta \cdot \textup{clip}(\frac{ L&amp;rsquo;_1(\theta_{[1]})}{\max{h_1,\epsilon}} ,\rho)\ \textup{and}\ \theta_{[2]} \leftarrow \theta_{[2]} - \eta \cdot \textup{clip}(\frac{ L&amp;rsquo;_2(\theta_{[2]})}{\max{h_2,\epsilon}},\rho)$$&lt;/li&gt;
&lt;li&gt;Here, $\rho$ is a constant to control the worst-case update size, $\epsilon$ is a very small constant (e.g., 1e-12) to avoid dividing by 0.&lt;/li&gt;
&lt;li&gt;The beauty here is that  when the curvature of some dimension is rapidly changing or negative and thus the second-order information is misleading and possibly leads to a huge update before clipping, the clipping mechanism kicks in and the optimizer defaults to SignGD (even though this is sub-optimal for benign situations).&lt;/li&gt;
&lt;li&gt;The black curve in the figure starts off similarly to SignGD due to the clipping mechanism in the non-convex region, making descent opposed to converging to a local maximum. In the convex valley, it converges to the global minimum with a few steps.&lt;/li&gt;
&lt;li&gt;Compared with SignGD and Adam, it makes much faster progress in the flat dimension $\theta_{[2]}$ (because the update is bigger in dimension $\theta_{[2]}$), while avoiding bouncing in the sharp dimension $\theta_{[1]}$ (because the update is significantly shrunk in the sharp dimension $\theta_{[1]}$).&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;sophia-second-order-clipped-stochastic-optimization&#34;&gt;Sophia: &lt;strong&gt;S&lt;/strong&gt;econd-&lt;strong&gt;o&lt;/strong&gt;rder Cli&lt;strong&gt;p&lt;/strong&gt;ped Stoc&lt;strong&gt;h&lt;/strong&gt;ast&lt;strong&gt;i&lt;/strong&gt;c Optimiz&lt;strong&gt;a&lt;/strong&gt;tion&lt;/h1&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/sophia.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/sophia.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;ema-of-diagonal-hessian-estimates&#34;&gt;EMA of diagonal Hessian estimates&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The diagonal Hessian estimates definitely have overheads, so it is computed at every $k$ steps.&lt;/li&gt;
&lt;li&gt;At every time step $t$, where $t \ \textup{mod} \ k = 1$, the estimator returns an estimate $h_t$ of the diagonal of the Hessian of the mini-batch loss.&lt;/li&gt;
&lt;li&gt;Similar to the gradient of the mini-batch loss function, the estimated diagonal Hessian can also have large noise.&lt;/li&gt;
&lt;li&gt;The EMA performed at every $k$ steps helps denoise the estimates. $$h_t = \beta_2 h_{t-k} + (1 - \beta_2) \hat{h}_{t} \ \textup{ if } t \ \mathrm{mod} \ k = 1 ; \textup{ else } h_t = h_{t-1}$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;per-coordinate-clipping&#34;&gt;Per-coordinate clipping&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I personally found this very innovative.&lt;/li&gt;
&lt;li&gt;As mentioned in the previous section, the inaccuracy of Hessian estimates and the change of Hessian along the trajectory can make the second-order information unreliable.&lt;/li&gt;
&lt;li&gt;$$\theta_{t+1} \leftarrow \theta_{t} - \eta_t \cdot \textup{clip}(m_t / \max{h_t,\epsilon}, \rho)$$&lt;/li&gt;
&lt;li&gt;When any entry of $h_t$ is negative, e.g., $h_t[i] &amp;lt; 0$, the corresponding entry in the pre-conditioned gradient $m_t[i]/\max{h_t[i],\epsilon} = m_t[i]/\epsilon$ is extremely large and has the same sign as $m_t[i]$, and thus $\eta\cdot \textup{clip}(m_t[i] / \max{h_t[i],\epsilon}, \rho) = \eta\rho\cdot \textup{sign}(m_t[i])$, which is the same as stochastic momentum SignSGD.&lt;/li&gt;
&lt;li&gt;Sophia uses stochastic momentum SignSGD as a backup when the Hessian is negative (or mistakenly estimated to be negative or very small.)  We also note that t&lt;/li&gt;
&lt;li&gt;The clipping mechanism controls the worst-case size of the updates in all parameter dimensions to be at most $\rho$, which also improves the stability (which could be a severe issue for second-order methods).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;diagonal-hessian-estimators&#34;&gt;Diagonal Hessian Estimators&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;ll keep this section short and brief, for the simple reason that the math is extremely interesting but also a bit difficult to understand. So, I&amp;rsquo;ll add references to the best of my knowledge and I encourage the reader to go through them thoroughly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hutchinsons-unbiased-estimator&#34;&gt;Hutchinson’s unbiased estimator&lt;/h3&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/hutchinson.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/hutchinson.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;For any loss function $\ell(\theta)$ on parameters $\theta\in \mathbb{R}^d$,  the Hutchinson&amp;rsquo;s estimator can be used to obtain an unbiased estimator for the diagonal of the Hessian.&lt;/li&gt;
&lt;li&gt;First, draw $u\in \mathbb{R}^d$ from the spherical Gaussian distribution $\mathcal{N}(0,\mathrm{I}_d)$, and then output $\hat{h} = u \odot (\nabla^2 \ell(\theta) u)$, where $\odot$ denotes the element-wise product, and $\nabla^2 \ell(\theta) u$ is the HVP of the Hessian with $u$.&lt;/li&gt;
&lt;li&gt;Using HVP (from &lt;a href=&#34;https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html#hessian-vector-products-using-both-forward-and-reverse-mode&#34;&gt;JAX&lt;/a&gt; or &lt;a href=&#34;https://pytorch.org/docs/stable/generated/torch.autograd.functional.hvp.html&#34;&gt;Pytorch&lt;/a&gt; allows us to efficiently compute the product of the Hessian and a vector without the actual computation of the full Hessian matrix.&lt;/li&gt;
&lt;li&gt;Effectively, $\mathbb{E}[\hat h] = \mathrm{diag}(\nabla^2 \ell(\theta))$.
&lt;br&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How does it work?&lt;/strong&gt; The idea for the above comes from the original paper from Hutchinson - &amp;ldquo;A stochastic estimator of the trace of the influence matrix for Laplacian smoothing splines&amp;rdquo; which was about estimating the trace of a matrix. The idea there was -  












&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig3.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig3.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;Dimensionally, and somewhat intuitively, it kinda makes sense to change the dot product to an elementwise product to get the non-aggregated estimate of the diagonal (since trace is the sum of the diagonal elements).&lt;/li&gt;
&lt;li&gt;This idea was also used in the &lt;a href=&#34;https://arxiv.org/abs/2006.00719&#34;&gt;&amp;ldquo;Hessian Diagonal Approximation&amp;rdquo; section of the AdaHessian paper&lt;/a&gt;, and I would also encourage the reader to go through &lt;a href=&#34;https://www-users.cse.umn.edu/~saad/PDF/umsi-2005-082.pdf&#34;&gt;Section 2 of the paper - &amp;ldquo;An Estimator for the Diagonal of a Matrix&amp;rdquo;&lt;/a&gt;, which the AdaHessian paper cites as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gauss-newton-bartlett-gnb-estimator&#34;&gt;Gauss-Newton-Bartlett (GNB) estimator&lt;/h3&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/gnb.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/gnb.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;The math for this section is particularly interesting and I would redirect you to my &lt;a href=&#34;https://github.com/shreyansh26/Annotated-ML-Papers/blob/main/ML%20Theory/Sophia%20-%20A%20Scalable%20Stochastic%20Second-order%20Optimizer%20for%20Language%20Model%20Pretraining.pdf&#34;&gt;annotated paper&lt;/a&gt; where I have mentioned references and also worked out some of the math.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;d highly recommend reading &lt;a href=&#34;https://www.cs.toronto.edu/~rgrosse/courses/csc2541_2022/readings/L02_Taylor_approximations.pdf&#34;&gt;Section 4.4 of these notes&lt;/a&gt; and optionally &lt;a href=&#34;https://www.cs.toronto.edu/~rgrosse/courses/csc2541_2022/readings/L03_metrics.pdf&#34;&gt;Section 4 of these notes&lt;/a&gt; (not absolutely required, just helps to understand the footnote in the Sophia paper).&lt;/li&gt;
&lt;li&gt;Ultimately, the GNB estimator used by the authors is $$B \cdot \nabla_\theta \widehat L(\theta) \odot \nabla_\theta \widehat L(\theta)$$ where $\widehat L(\theta) = \frac{1}{B}\sum_{b=1}^B \ce(f(\theta, x_b), \hat{y}_b)$, here $\hat{y}_b$ are not the labels corresponding to $x_b$. They are just  __sampled labels__  from the mini-batch.&lt;/li&gt;
&lt;li&gt;The reason we can do that is in the math, which comes from the combination of
&lt;ol&gt;
&lt;li&gt;The claim in the paper that the second-order derivative of the loss w.r.t. the logits only depends on the logits and the true labels $y$.&lt;/li&gt;
&lt;li&gt;Bartlett’s first identity, which generally holds for the negative log-likelihood loss of any probabilistic model  and which states - $$\forall b, ~~\mathbb{E}_{\hat{y}&lt;em&gt;b}\nabla \ell&lt;/em&gt;{\textup{ce}}(f(\theta,x_b),\hat{y}_b) = 0$$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Also, the above estimator is an unbiased estimator for the diagonal of the Gauss-Newton matrix, which is a biased estimator for the diagonal of the Hessian.&lt;/li&gt;
&lt;li&gt;Additional References - &lt;a href=&#34;https://www.sfu.ca/~lockhart/richard/830/12_3/Summaries/8.pdf&#34;&gt;Bartlett Identities&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;comparison-of-hessian-estimators&#34;&gt;Comparison of Hessian estimators&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Hutchinson’s estimator does not assume any structure of the loss, but requires a Hessian-vector product.&lt;/li&gt;
&lt;li&gt;The GNB estimator only estimates the Gauss-Newton term but always gives a positive semi-definite (non-negative) diagonal Hessian estimate. The PSDness ensures that the pre-conditioned update is always a descent direction.&lt;/li&gt;
&lt;li&gt;The Gauss-Newton Matrix is guaranteed to be PSD if the above-mentioned second-order derivative of the loss w.r.t. the logits is PSD. For proof, &lt;a href=&#34;https://andrew.gibiansky.com/blog/machine-learning/gauss-newton-matrix/&#34;&gt;refer this&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;experiments&#34;&gt;Experiments&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;There are tons of details in the paper regarding the experiments. I&amp;rsquo;ll just mention the key points here, just in case I have to look up something quickly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;experimental-setup&#34;&gt;Experimental Setup&lt;/h2&gt;
&lt;h3 id=&#34;baselines&#34;&gt;Baselines&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Main comparison with AdamW and Lion&lt;/li&gt;
&lt;li&gt;AdamW for GPT2 hyperparams - WD = 0.1, $\beta_1 = 0.9$ and $\beta_2 = 0.95$&lt;/li&gt;
&lt;li&gt;Lion fro GPT2 hyperparams - $\beta_1 = 0.95$ and $\beta_2 = 0.98$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Batch Size = 480&lt;/li&gt;
&lt;li&gt;Cosine LR schedule with the final LR equal to 0.05 times the peak LR&lt;/li&gt;
&lt;li&gt;Standard gradient clipping (by norm) threshold 1.0&lt;/li&gt;
&lt;li&gt;Fixed 2k steps of LR warm-up&lt;/li&gt;
&lt;li&gt;For Sophia, the authors use $\beta_1 = 0.96$, $\beta_2 = 0.99$, $\epsilon=$ 1e-12 and update diagonal Hessian every 10 steps.&lt;/li&gt;
&lt;li&gt;Sophia-H (which refers to Sophia with Hutchinson estimator) uses $\rho=0.01$, and only a subset of 32 examples from the mini-batch to calculate the diagonal Hessian to further reduce overhead.&lt;/li&gt;
&lt;li&gt;Sophia-G (which refers to Sophia with GNB estimator) uses $\rho=20$, and use a subset of 240 examples from the mini-batch to calculate the diagonal Gauss-Newton.&lt;/li&gt;
&lt;li&gt;All models are trained in bfloat16.&lt;/li&gt;
&lt;li&gt;The 125M and 355M models are trained on A5000 GPUs, while the 770M models are trained on A100 GPUs. Total amount of compute spent on all experiments is about 6000 hours on A100s and 10000 hours on A5000s. This amounts to 4.38e21 FLOPs.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;results&#34;&gt;Results&lt;/h1&gt;
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/xxTaqsxFBU8XN3dgfQK36JrZPD8oh6Qbff451sCN-YogrFHMuBChP6hMheJpGEwD6ll9r2qZkTjD-mhAC01nnbFEQBXgeCDaMBIn-pEmVMRjjzLgKJfl6hM3bMNp7fxg.png)  --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig4.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig4.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Sophia consistently achieves better validation loss than AdamW and Lion.&lt;/li&gt;
&lt;li&gt;As the model size grows, the gap between Sophia and baselines also becomes larger. Sophia-H and Sophia-G both achieve a 0.04 smaller validation loss on the 355M model,   Sophia-H achieves a 0.05 smaller validation loss on the 770M model with the same 100k steps.&lt;/li&gt;
&lt;/ul&gt;
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/ajIHZESSHf_LXT0W9rCEACxW2-LPTHapJuIWfNEDHsOU7OC9KDlj1k8f-uBgjx4gRbysa5rmtlst9tg7GhystKdPzPNZNqVGIaDTbB6sVCM1IBEbBtvt3DG9KRuRvOjn.png)  --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig5.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig5.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;According to the scaling laws in this regime, an improvement in loss of 0.05 is equivalent to 2x improvement in terms of number of steps or total compute to achieve the same validation loss&lt;/li&gt;
&lt;li&gt;Sophia is 2x faster in terms of number of steps, total compute and wall-clock time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;The scaling law is in favor of Sophia-H over AdamW&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;The 540M model trained by Sophia-H has smaller loss than the 770M model trained by AdamW.&lt;/li&gt;
&lt;li&gt;The 355M model trained by Sophia-H has comparable loss as the 540M model trained by AdamW.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Few-shot Evaluation on Downstream Tasks (SuperGLUE)&lt;/strong&gt;
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/SfXdQSEchScxBjUlKfiaAfx55WHF6zoAuAral2hhMHAUD_HJDU6-1MdLpkBHJ2Al3K0lq4_SiLIgunAOQyAus5Y2-m68nMYXaNnqrgNIPvkoRzgTYxT_LnnDOwgEbULT.png)  --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig6.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig6.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;GPT-2 medium and GPT-2 large pre-trained with Sophia have better few-shot accuracy on most subtasks.&lt;/li&gt;
&lt;li&gt;Models pre-trained with Sophia-H have comparable few-shot accuracy as models pre-trained with AdamW for 2x number of steps.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sensitivity to $\rho$ and $\beta_2$, and transferability of hyperparameters&lt;/strong&gt;
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/Q7I5-Z7KY7-YFsggDfNZgfzslMPVlP1slvOSScfIjmUu8izJuPCGl63B3D3cVl8tzwY2VC2rCMd-WFb8qZ437vYcDmysNNq0DIi1qUDgvZqW_9sH-40bfeWoQSwDf4LH.png)  --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig7.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig7.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;While performing grid search on hyperparams on a smaller 30M model, the authors found that  all combinations have a similar performance. Moreover, this hyperparameter choice is transferable across model sizes. For all the experiments on 125M, 355M and 770M, we use the hyperparameters searched on the 30M model, which is ρ = 0.01, β2 = 0.99.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Training Stability&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Gradient clipping (by norm) is an important technique in language model pre-training as it avoids messing up the moment of gradients with one mini-batch gradient computed from rare data.&lt;/li&gt;
&lt;li&gt;In practice, the frequency that gradients clipping is triggered is related to the training stability - if the gradient is frequently clipped, the iterate can be in a very unstable state.&lt;/li&gt;
&lt;/ul&gt;
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/4S5g8pYpt1RJq2GnQH3YvM6-IG_WW2GdnciFI0_B6_sn0CxqvrWPFzpyTUePG5kYcjFf7j2MijUIrPTUN9hXC_osIlt-co6i3K6DdSw86sMwdaJaikvm8RlsZ2YE7_KS.png)  --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig8.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig8.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Although all methods use the same clipping threshold 1.0, Sophia-H seldomly triggers gradient clipping, while AdamW and Lion trigger gradient clipping in more than 10% of the steps&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Another common trick of pre-training deep Transformers is scaling the product of keys and values by the inverse of the layer index [&lt;a href=&#34;https://crfm.stanford.edu/2021/08/26/mistral.html&#34;&gt;Mistral&lt;/a&gt;]. This stabilizes training and increases the largest possible learning rate.
  &lt;!-- - ![](local://C:/Users/shrey/remnote/remnote-64285e10d2c548ebfefc88aa/files/UCHToiptemrq7v8SwQxEqoXJF1oSgfyQU3-k9bVZjYs-GxwX30vLNv9k-S5WpaFqwHEme2T9n7Pl-VwvPUUXm9eMIKQ9lKXd2yAaqr3q93LnyjKJRoNOfzewvFvUtXwe.png)  --&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig9.png&#34; data-caption=&#34;Source - https://arxiv.org/abs/2305.14342&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-05-28_sophia_scalable_second_order_optimizer_llms/images/fig9.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Source - &lt;a href=&#34;https://arxiv.org/abs/2305.14342&#34;&gt;https://arxiv.org/abs/2305.14342&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Without this trick, the maximum learning rate of AdamW and Lion on GPT-2 medium (355M) can only be 1.5e-4, which is much smaller than 3e-4 with the trick (the loss will blow up with 3e-4 without the trick). Moreover, the loss decreases much slower without the trick as shown. In all the experiments, Sophia-H does not require scaling the product of keys and values by the inverse of the layer index.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;limitations&#34;&gt;Limitations&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Scaling up to larger models and datasets
&lt;ul&gt;
&lt;li&gt;The paper only experiments with GPT-2 pretraining on OpenWebText for model sizes up to 770M params.&lt;/li&gt;
&lt;li&gt;Although it is faster and better than Adam and Lion in these set of experiments, and the   scaling laws and pre-training stability are encouraging, it remains to be seen how well Sophia scales on larger models.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Holistic downstream evaluation
&lt;ul&gt;
&lt;li&gt;The paper has only experimented with 4 SuperGLUE tasks and although the results are encouraging, a better downstream evaluation is still important.&lt;/li&gt;
&lt;li&gt;To note - The limitation in downstream evaluation is also due to the limited model size, because language models at this scale do not have enough capabilities such as in-context learning, and mathematical reasoning.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Evaluation on other domains
&lt;ul&gt;
&lt;li&gt;This paper focuses on optimizers for LLMs, it should be evaluated in other domains like CV, RL and Multimodal tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;A very exciting paper. Hope people can test it out on even bigger models and across multiple domains and we may potentially have an optimizer finally dethroning Adam!&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js&#34; data-dojo-config=&#34;usePlainJson: true, isDebug: false&#34;&gt;&lt;/script&gt;
&lt;!-- &lt;button style=&#34;background-color: #70ab17; color: #1770AB&#34; id=&#34;openpopup&#34;&gt;Subscribe to my posts!&lt;/button&gt; --&gt;
&lt;div class=&#34;button_cont&#34; align=&#34;center&#34;&gt;&lt;button id=&#34;openpopup&#34; class=&#34;example_a&#34;&gt;Subscribe to my posts!&lt;/button&gt;&lt;/div&gt;
&lt;style&gt;
    .example_a {
        color: #fff !important;
        text-transform: uppercase;
        text-decoration: none;
        background: #3f51b5;
        padding: 20px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        border: none;
        transition: all 0.4s ease 0s;
    }

    .example_a:hover {
        background: #434343;
        letter-spacing: 1px;
        -webkit-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        -moz-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        box-shadow: 5px 40px -10px rgba(0,0,0,0.57);
        transition: all 0.4s ease 0s;
    }
&lt;/style&gt;
&lt;script type=&#34;text/javascript&#34;&gt;

function showMailingPopUp() {
    window.dojoRequire([&#34;mojo/signup-forms/Loader&#34;], function(L) { L.start({&#34;baseUrl&#34;:&#34;mc.us4.list-manage.com&#34;,&#34;uuid&#34;:&#34;0b10ac14f50d7f4e7d11cf26a&#34;,&#34;lid&#34;:&#34;667a1bb3da&#34;,&#34;uniqueMethods&#34;:true}) })

    document.cookie = &#34;MCPopupClosed=;path=/;expires=Thu, 01 Jan 1970 00:00:00 UTC&#34;;
}

document.getElementById(&#34;openpopup&#34;).onclick = function() {showMailingPopUp()};

&lt;/script&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Follow me on &lt;a href=&#34;https://twitter.com/shreyansh_26&#34;&gt;Twitter&lt;/a&gt;, &lt;a href=&#34;https://github.com/shreyansh26&#34;&gt;Github&lt;/a&gt; or connect on &lt;a href=&#34;https://www.linkedin.com/in/shreyansh26/&#34;&gt;LinkedIn&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Summary #8 - FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness</title>
      <link>https://shreyansh26.github.io/post/2023-03-26_flash-attention/</link>
      <pubDate>Sun, 26 Mar 2023 15:47:48 +0530</pubDate>
      <guid>https://shreyansh26.github.io/post/2023-03-26_flash-attention/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Paper&lt;/strong&gt;: FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness&lt;br&gt;
&lt;strong&gt;Link&lt;/strong&gt;: &lt;a href=&#34;https://arxiv.org/abs/2205.14135&#34;&gt;https://arxiv.org/abs/2205.14135&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;Authors&lt;/strong&gt;: Tri Dao, Daniel Y. Fu, Stefano Ermon, Atri Rudra, Christopher Ré&lt;br&gt;
&lt;strong&gt;Code&lt;/strong&gt;: &lt;a href=&#34;https://github.com/HazyResearch/flash-attention&#34;&gt;https://github.com/HazyResearch/flash-attention&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I have also released an annotated version of the paper. If you are interested, you can find it &lt;a href=&#34;https://github.com/shreyansh26/Annotated-ML-Papers/blob/main/General-DL/FlashAttention%20-%20Fast%20and%20Memory-Efficient%20Exact%20Attention.pdf&#34;&gt;here&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;I finished reading the FlashAttention paper recently and thought that it would be good to have a technical write-up of the paper, so that it can help me understand the concept well. I decided to make it public and hopefully it can help anyone reading this.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;Attention as we know, in its standard implementation is an $O(N^2)$ operation, where N is the sequence length. There are many approximate attention methods out there like Reformer, Smyrf, Reformer, Performer and others (&lt;a href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/&#34;&gt;you can find more details on a few of these in my previous blog&lt;/a&gt;) which aim to reduce the compute requirements to linear or near-linear in sequence length, but many of them do not display wall-clock speedup against standard attention. They focus on FLOP reduction (which doesn&amp;rsquo;t always correlate with wall-clock speed) and tend to ignore overheads from memory access (IO).FlashAttention aims to incorporate IO-awareness i.e. dividing operations between faster and slower levels of GPU memory to make the whole computation faster. The algorithm uses tiling to reduce the number of memory reads/writes between GPU high bandwidth memory (HBM) and GPU on-chip SRAM. FlashAttention can also be extended to block-spare attention and this results in the fastest approximate (or not) attention algorithm out there.&lt;/p&gt;
&lt;p&gt;All this helps to improve the training time of Transformer models - a 15% end-to-end wall-clock speedup on BERT-large (seq. length 512) compared to the MLPerf 1.1 training speed record, 3× speedup on GPT-2 (seq. length 1K). This memory-efficient approach also helps to incorporate a longer context (up to 16k/64k tokens) which also results in better models (0.7 better perplexity on GPT-2).&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;ll describe more details in the future sections.&lt;/p&gt;
&lt;h2 id=&#34;background---hardware-performance&#34;&gt;Background - Hardware Performance&lt;/h2&gt;
&lt;p&gt;Since FlashAttention computes exact attention, and the major crux of their work is the efficient hardware usage, it is important to know a bit about GPU memory and the performance characteristics of various kinds of operations on it.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/gpu_mem.png&#34; data-caption=&#34;A100 GPU Memory Hierarchy. Source - https://arxiv.org/abs/2205.14135&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/gpu_mem.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    A100 GPU Memory Hierarchy. Source - &lt;a href=&#34;https://arxiv.org/abs/2205.14135&#34;&gt;https://arxiv.org/abs/2205.14135&lt;/a&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;gpu-memory-hierarchy&#34;&gt;GPU Memory Hierarchy&lt;/h3&gt;
&lt;p&gt;For a A100 GPU with 40GB of High Memory Bandwidth (HBM), a rough diagram of the memory hierarchy is shown above. The SRAM memory us spread across 108 streaming multiprocessors (SMs), 192KB for each. As one can see, the on-chip SRAM is much faster the HBM but is much smaller than size. In terms of compute, the theoretical peak throughput for BFLOAT16 using Tensor Core is 312 TFLOPS. With time, compute has gotten much faster relative to memory speed, hence processes (operations) are increasingly bottlenecked by memory (HBM) access. Thus, the goal of the FlashAttention paper was to use the SRAM as well as efficiently as possible to speed up the computation.&lt;/p&gt;
&lt;h3 id=&#34;execution-model&#34;&gt;Execution Model&lt;/h3&gt;
&lt;p&gt;he typical way in which GPUs operate are that they use a large number of threads to perform an operation, which is called a kernel. The input is loaded from the HBM to the registers and SRAM, and written back to the HBM after computation.&lt;/p&gt;
&lt;h3 id=&#34;performance-characteristics&#34;&gt;Performance Characteristics&lt;/h3&gt;
&lt;p&gt;There is a term called &lt;strong&gt;arithmetic intensity&lt;/strong&gt; which is given by the number of arithmetic operations per byte of memory access. It helps to understand the bottleneck of an operation. An operation can be characterized as compute-bound (also called math-bound) or memory-bound.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Compute-bound&lt;/strong&gt; - When the bottleneck is the compute i.e., the time taken by the operation is determined by how many arithmetic operations there are since the time taken due to HBM accesses is relative lower. E.g. of such operations are matrix multiplication with large inner dimension, and convolution with large number of channels.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Memory-bound&lt;/strong&gt; - When the bottleneck is the memory i.e., the time taken by the operation is determined by the number of memory accesses there are since the time spent in computation is relative lower. E.g. of such processes are most other operation like elementwise operations - activation, dropout and reduction operations - sum, softmax, batch normalization, layer normalization.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To understand this better, let&amp;rsquo;s analyze it mathematically. Let $N_{op}$ be the number of arithmetic/floating point operations, $N_{byte}$ be the number of memory accesses, ${BW}_{compute}$ and ${BW}_{memory}$ be the compute and memory bandwidth respectively, the time taken for compute operations and memory accesses can be determined as -&lt;/p&gt;
&lt;p&gt;$$t_{compute} = \frac{N_{op}}{{BW}_{compute}}$$
$$t_{memory} = \frac{N_{byte}}{{BW}_{memory}}$$&lt;/p&gt;
&lt;p&gt;The operation is compute-bound if $t_{compute}$ is greater than $t_{memory}$ and vice-versa for memory bound. Which mathematically becomes -&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For compute-bound&lt;/strong&gt;
$$\frac{N_{op}}{N_{byte}} \gt \frac{{BW}_{compute}}{{BW}_{memory}}$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;For memory-bound&lt;/strong&gt;
$$\frac{N_{op}}{N_{byte}} \lt \frac{{BW}_{compute}}{{BW}_{memory}}$$&lt;/p&gt;
&lt;p&gt;As mentioned above as well, matrix multiplication for large inner dimensions is compute bound but below that it is memory bound. If using FP32 and plugging in numbers for A100 40GB, then for $N \lt 74$, the $N \times N$ multiplication is memory bound, but compute bound when $N$ is greater than that. A great and detailed resource to understand this theory is this &lt;a href=&#34;https://leimao.github.io/blog/Math-Bound-VS-Memory-Bound-Operations/&#34;&gt;blog post by Lei Mao&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;kernel-fusion&#34;&gt;Kernel Fusion&lt;/h3&gt;
&lt;p&gt;Kernel Fusion is often down by compilers to fuse together multiple elementwise operations. It is used to accelerate memory-bound operations. The basic ideas is that instead of loading the input from the HBM, performing the operation and writing back to the HBM and repeating that for each operation applied to the same input, the operation can be fused so that all of the operations are performed at once when the input is loaded from the HBM.&lt;/p&gt;
&lt;p&gt;However, one must note that when performing model training, the effectiveness of kernel fusion is reduced as the intermediate values still have to be written to the HBM to save for the backward pass.&lt;/p&gt;
&lt;h2 id=&#34;background---standard-attention&#34;&gt;Background - Standard Attention&lt;/h2&gt;
&lt;p&gt;For anyone familiar with transformers, this equation is well-known -&lt;/p&gt;
&lt;p&gt;$$Attention(Q, K, V) = softmax(\frac{QK^\mathsf{T}}{\sqrt{d_k}})V$$&lt;/p&gt;
&lt;p&gt;Here, the sequences $Q, K, V  \in \mathbb{R}^{N \times d}$ where $N$ is the sequence length and $d$ is the head dimension. The attention output, above, can be denoted by $O \in \mathbb{R}^{N \times d}$. The equation can be broken down as -&lt;/p&gt;
&lt;p&gt;$$\mathbf{S} = \mathbf{QK^\mathsf{T}} \in \mathbb{R}^{N \times N},\quad \mathbf{P} = softmax(\mathbf{S}) \in \mathbb{R}^{N \times N},\quad \mathbf{O} = \mathbf{PV} \in \mathbb{R}^{N \times d}$$&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/att2.png&#34; data-caption=&#34;Scaled Dot Product Attention&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/att2.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Scaled Dot Product Attention
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;In standard attention implementations, the $\mathbf{S}$ and $\mathbf{P}$ matrices are materialized in the HBM, which takes $O(N^2)$ memory. Also, most operations are memory-bound/elementwise operations, e.g. softmax applied on $\mathbf{P}$, masking applied to $\mathbf{S}$, dropout applied to $\mathbf{P}$. This leads to slow wall-clock time.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/standard-att-algo.png&#34; data-caption=&#34;Standard Attention Implementation&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/standard-att-algo.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Standard Attention Implementation
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;flashattention---algorithm-details&#34;&gt;FlashAttention - Algorithm details&lt;/h2&gt;
&lt;p&gt;As one may understand, the materialization of the $N \times N$ attention matrix on the HBM and its repeated reading and writing is a major bottleneck. To solve this, two main things need to be done -&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Computing the softmax reduction without access to the whole input&lt;/li&gt;
&lt;li&gt;Not storing the large intermediate attention matrix for the backward pass&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Two established techniques, namely &lt;strong&gt;tiling&lt;/strong&gt; and &lt;strong&gt;recomputation&lt;/strong&gt; are used to solve this.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tiling - The attention computation is restructured to split the input into blocks and performing the softmax operation incrementally by making several passes over the input blocks.&lt;/li&gt;
&lt;li&gt;Recomputation - The softmax normalization factor from the forward pass is stored to quickly recompute attention on-chip in the backward pass, which is faster than the standard attention approach of reading the intermediate matrix from HBM.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This does lead to increased FLOPs due to recomputation, however FlashAttention runs both faster (up to 7.6x on GPT-2) and uses less memory — linear in sequence length, due to the massively reduced amount of HBM access.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/gpt2-att-speedup.png&#34; data-caption=&#34;Speedup over the PyTorch implementation of attention on GPT-2&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/gpt2-att-speedup.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Speedup over the PyTorch implementation of attention on GPT-2
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;understanding-the-algorithm&#34;&gt;Understanding the algorithm&lt;/h3&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/flash-attention-schematic.png&#34; data-caption=&#34;FlashAttention Forward Pass Algorithm&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/flash-attention-schematic.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    FlashAttention Forward Pass Algorithm
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;The main idea behind the algorithm is to split the inputs $\mathbf{Q, K, V}$ into blocks, loading them from slow HBM to fast SRAM and then computing the attention output w.r.t those blocks. The output of each block is scaled by the right normalization factor before adding them up, which gives the correct result.&lt;/p&gt;
&lt;p&gt;$$\mathbf{S} = \mathbf{\tau QK^\mathsf{T}} \in \mathbb{R}^{N \times N},\quad \mathbf{S}^\mathrm{masked} = \mathrm{MASK}(S) \in \mathbb{R}^{N \times N},\quad \mathbf{P} = softmax(\mathbf{S^\mathrm{masked}}) \in \mathbb{R}^{N \times N},$$&lt;/p&gt;
&lt;p&gt;$$\mathbf{P}^\mathrm{dropped} = \mathrm{dropout}(\mathbf{P}, p_\mathrm{drop}), \quad \mathbf{O} = \mathbf{P^\mathrm{dropped}V} \in \mathbb{R}^{N \times d},$$&lt;/p&gt;
&lt;p&gt;where $\tau \in \mathbb{R}$ is some softmax scaling factor (typically $\frac{1}{\sqrt{d}}$), $\mathrm{MASK}$ is some masking function that sets some entries of
the input to $-\infty$ and keep other entries the same, and $\mathrm{dropout}(x, p)$ applies dropout to 𝑥 elementwise (i.e., output $\frac{x}{1-p}$ with probability $1 − p$ and output $0$ with probability $p$ for each element $x$)&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/flash-attention-forward-algo.png&#34; data-caption=&#34;FlashAttention Forward Pass Algorithm&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/flash-attention-forward-algo.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    FlashAttention Forward Pass Algorithm
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;tiling&#34;&gt;Tiling&lt;/h4&gt;
&lt;p&gt;The key part in understanding the block-wise computation of attention in the algorithm above is the block-wise computation of the softmax. The paper explains it well though. The softmax of a vector $x \in \mathbb{R}^B$ can be computed as -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/softmax-1.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/softmax-1.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;And for vectors $x^\mathrm{(1)}, x^\mathrm{(2)} \in \mathbb{R}^B$, the softmax of the concatenated $x = [x^\mathrm{(1)}, x^\mathrm{(2)}] \in \mathbb{R}^{2B}$ is given by -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/softmax-2.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/softmax-2.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;Let&amp;rsquo;s understand this better. In the above equations, $m(x)$ holds the maximum between $m(x^\mathrm{(1)})$ and $m(x^\mathrm{(2)})$. Now, $m(x^\mathrm{(1)})$ is the maximum element of $x^\mathrm{(1)}$ and $m(x^\mathrm{(2)})$ is the maximum element of $x^\mathrm{(2)}$ which means that $m(x)$ is basically the maximum of the whole concatenated vector. The beauty is that this was done blockwise.&lt;/p&gt;
&lt;p&gt;So, if statistics $(m(x), l(x))$ are tracked then softmax can be computed one block at a time. In line 12 of the algorithm, $\tilde{m_{ij}}$ has the maximum element of each row of $S_{ij}^\mathrm{masked}$, and next in line 13, $m_i^\mathrm{new}$ holds the row-wise maximum of the $m_i$ till now and the new one i.e., $\tilde{m_{ij}}$. Hence $m_i$ is updated every column from the outer loop and eventually stores the row-wise max of the matrix $\mathbf{S}$. The same logic goes for $l_i$ and the matrix $\mathbf{P}$. The results are combined to get the output attention matrix in line 15.&lt;/p&gt;
&lt;h4 id=&#34;recomputation&#34;&gt;Recomputation&lt;/h4&gt;
&lt;p&gt;The backward pass of FlashAttention requires the $\mathbf{S}$ and $\mathbf{P}$ matrices to compute the gradients w.r.t $\mathbf{Q}$,$\mathbf{K}$,$\mathbf{V}$. However, they are $N \times N$ matrices and as it can be seen in the algorithm above, they aren&amp;rsquo;t stored explicitly. The trick is to use the output $\mathbf{O}$ and the softmax normalization statistics $(m, l)$, we can recompute the attention matrix $\mathbf{S}$ and $\mathbf{P}$ easily in the backward pass from blocks of $\mathbf{Q}$,$\mathbf{K}$,$\mathbf{V}$ in SRAM. even with more FLOPs, the recomputation step speeds up the backward pass due to reduced HBM accesses. The backward pass is very interesting too but slightly more complicated hence I&amp;rsquo;ll probably cover it in a separate post. One can cover the Appendix B of the paper to learn more.&lt;/p&gt;
&lt;p&gt;Kernel Fusion is also used to implement the algorithm in one CUDA kernel, loading input from HBM, performing all the computation steps (matrix multiply, softmax, optionally masking and dropout, matrix multiply), then writing the result back to HBM. This avoids repeatedly reading and writing of inputs and outputs from and to HBM.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important Information&lt;/strong&gt; - &lt;em&gt;The FlashAttention algorithm computed $\mathbf{O} = softmax(QK^\mathsf{T})V$ with $O(N^2d)$ FLOPs and requires $O(N)$ additional memory beyond inputs and output (for the $(l, m)$ statistics).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The proof for the FLOPs calculation is given in Appendix C of the paper, which should be checked out by the curious reader.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Important Information&lt;/strong&gt; - &lt;em&gt;Let $N$ be the sequence length, $d$ be the head dimension, and $M$ be the size of SRAM with $d \leq M \leq Nd$. Standard attention requires $\Theta(Nd + N^2)$ HBM accesses while FlashAttention requires $\Theta(N^2d^2M^{-1})$ HBM accesses.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For typical values of $d$ (64-128) and $M$ (around 100KB), $d^2$ is many times smaller than $M$, and thus FlashAttention requires many times fewer HBM accesses than standard implementation. This leads to both faster execution and a lower memory footprint.&lt;/p&gt;
&lt;p&gt;The authors also go on to show that the number of HBM accesses by FlashAttention is a lower-bound. There can be no implementation which can asymptotically improve on the number of HBM accesses for all values of $M$ when doing exact attention calculation.&lt;/p&gt;
&lt;p&gt;As the block size increases, the number of HBM accesses decreases as there are less passes over the input, and the runtime also decreases. However, beyond 256, the runtime starts getting bottlenecked by factors like arithmetic operations. And there is also a limit on how large we can choose the block size to be, as we want it to be able to fit in the SRAM.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-1.png&#34; data-caption=&#34;Left - Comparison of standard attention and FlashAttention for GPT-2 medium on A100. Despite the higher FLOPs (due to the recomputation step in backward pass), the lesser number of HBM access leads to a much faster runtime. Right - The effect of block size on the forward runtime and HBM accesses.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-1.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    &lt;strong&gt;Left&lt;/strong&gt; - Comparison of standard attention and FlashAttention for GPT-2 medium on A100. Despite the higher FLOPs (due to the recomputation step in backward pass), the lesser number of HBM access leads to a much faster runtime. &lt;strong&gt;Right&lt;/strong&gt; - The effect of block size on the forward runtime and HBM accesses.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;block-sparse-flashattention&#34;&gt;Block-Sparse FlashAttention&lt;/h3&gt;
&lt;p&gt;As mentioned in the overview, FlashAttention can be used to make a approximate attention algorithm as well. The authors call it Block-Sparse FlashAttention and it is the fastest approximate attention algorithm. The memory complexity is smaller than FlashAttention by a factor proportional to the sparsity.&lt;/p&gt;
&lt;p&gt;For inputs $\mathbf{Q, K, V} \in \mathbb{R}^{N \times d}$ and a mask $\tilde{\mathbf{M}} \in { 0,1 }^{N \times N}$, we want to calculate -&lt;/p&gt;
&lt;p&gt;$$\mathbf{S} = \mathbf{QK^\mathsf{T}} \in \mathbb{R}^{N \times N},\quad \mathbf{P} = softmax(\mathbf{S} \odot \mathbb{1}_{\tilde{\mathbf{\mathrm{M}}}}) \in \mathbb{R}^{N \times N},\quad \mathbf{O} = \mathbf{PV} \in \mathbb{R}^{N \times d}$$&lt;/p&gt;
&lt;p&gt;Given a pre-defined block sparsity mask $\mathbf{M} \in { 0,1 }^{N/B_r \times N/B_c}$, Algorithm 2 above can be adapted to only compute the nonzero blocks of the attention matrix. We can just skip the zero blocks. The Algorithm shown below describes the forward pass of Block-sparse FlashAttention.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/blocksparse-flash-attention-forward-algo.png&#34; data-caption=&#34;Blcok-Sparse FlashAttention Forward Pass Algorithm&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/blocksparse-flash-attention-forward-algo.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Blcok-Sparse FlashAttention Forward Pass Algorithm
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Important Information&lt;/strong&gt; - &lt;em&gt;Let $N$ be the sequence length, $d$ be the head dimension, and $M$ be the size of SRAM with $d \leq M \leq Nd$. Block-sparse FlashAttention requires $\Theta(Nd + N^2d^2M^{-1}s)$ HBM accesses where $s$ is the fraction of nonzero blocks in the block-sparsity mask.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For large sequence lengths, $s$ is set to $N^{-1/2}$ or $N^{-1} \log N$ resulting in $\Theta(N \sqrt{N})$ or $\Theta(N \log N)$ IO complexity. As the sparsity increases, the runtime of block-sparse FlashAttention improves proportionally.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-2.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-2.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;experiments&#34;&gt;Experiments&lt;/h2&gt;
&lt;p&gt;There are tons of results in the paper. But the TL;DR is that FlashAttention beats all other exact attention algorithms in both training speed and quality of the models/down stream models especially when pushed to the limits of sequence length. I&amp;rsquo;ll add the plots and graphs for their various results here. Additional results are present in the paper.&lt;/p&gt;
&lt;h3 id=&#34;training-speed&#34;&gt;Training Speed&lt;/h3&gt;
&lt;h4 id=&#34;bert&#34;&gt;BERT&lt;/h4&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-3.png&#34; data-caption=&#34;Training time of BERT-large. starting from the same initialization provided by the MLPerf benchmark, to reach the target accuracy of 72.0% on masked language modeling. Averaged over 10 runs on 8×A100 GPUs.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-3.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Training time of BERT-large. starting from the same initialization provided by the MLPerf benchmark, to reach the target accuracy of 72.0% on masked language modeling. Averaged over 10 runs on 8×A100 GPUs.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;gpt-2&#34;&gt;GPT-2&lt;/h4&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-4.png&#34; data-caption=&#34;GPT-2 small and medium using FlashAttention achieve up to 3× speed up compared to Huggingface implementation and up to 1.7× compared to Megatron-LM. Training time reported on 8×A100s GPUs.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-4.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    GPT-2 small and medium using FlashAttention achieve up to 3× speed up compared to Huggingface implementation and up to 1.7× compared to Megatron-LM. Training time reported on 8×A100s GPUs.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;long-range-arena&#34;&gt;Long-range Arena&lt;/h4&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-5.png&#34; data-caption=&#34;The performance of standard attention, FlashAttention, block-sparse FlashAttention, and approximate attention baselines on the Long-Range-Arena benchmarks. Each task has a different sequence length varying between 1024 and 4096.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-5.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    The performance of standard attention, FlashAttention, block-sparse FlashAttention, and approximate attention baselines on the Long-Range-Arena benchmarks. Each task has a different sequence length varying between 1024 and 4096.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Block-sparse FlashAttention is faster than all of the approximate attention methods that were tested.&lt;/p&gt;
&lt;h3 id=&#34;model-quality&#34;&gt;Model Quality&lt;/h3&gt;
&lt;h4 id=&#34;language-modeling-with-long-context&#34;&gt;Language Modeling with Long Context&lt;/h4&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-6.png&#34; data-caption=&#34;GPT-2 small with FlashAttention, with 4× larger context length compared to Megatron-LM, is still 30% faster while achieving 0.7 better perplexity. Training time on 8×A100 GPUs is reported.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-6.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    GPT-2 small with FlashAttention, with 4× larger context length compared to Megatron-LM, is still 30% faster while achieving 0.7 better perplexity. Training time on 8×A100 GPUs is reported.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;long-document-classification&#34;&gt;Long Document Classification&lt;/h4&gt;
&lt;p&gt;Since FlashAttention allows training on longer sequences, it improves performance on such datasets. MIMIC-III contains intensive care unit patient discharge summaries, each annotated with multiple labels. ECtHR contains legal cases from the European Court of Human Rights, each of which is mapped to articles of the Convention of Human Rights
that were allegedly violated. Both of these datasets contain very long text documents. The average number of tokens in MIMIC-III is 2395 tokens and the longest document contains 14562 tokens.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-7.png&#34; data-caption=&#34;Sequence length 16K outperforms length 512 by 4.3 points on MIMIC, and that length 8K outperforms length 512 by 8.5 points on ECtHR. The discrepancies may be due to subtle distribution shifts: MIMIC-III contains specialized medical text and thus may be more susceptible to a distribution shift in the document length, whereas ECtHR contains general language.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-7.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Sequence length 16K outperforms length 512 by 4.3 points on MIMIC, and that length 8K outperforms length 512 by 8.5 points on ECtHR. The discrepancies may be due to subtle distribution shifts: MIMIC-III contains specialized medical text and thus may be more susceptible to a distribution shift in the document length, whereas ECtHR contains general language.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;path-x-and-path-256&#34;&gt;Path-X and Path-256&lt;/h4&gt;
&lt;p&gt;These are challenging tasks from the long range arena benchmark where the task is to classify whether two points in a black and white 128×128 (or 256×256) image have a path connecting them, and the images are fed to the transformer one pixel at a time. No transformer model in the past has been able to model these tasks effectively. They have either ran out of memory or achieved random performance. FlashAttention yields the first Transformer that can achieve better-than-random performance on the challenging Path-X task (sequence length 16K), and block-sparse FlashAttention yields the first sequence model that can achieve better-than-random performance on Path-256 (sequence length 64K).&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-8.png&#34; data-caption=&#34;First Transformer model that can achieve non-random performance on Path-X and Path-256. Path-256 requires longer sequences but has relatively shorter paths than Path-X, so it is easier to obtain a higher accuracy.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-8.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    First Transformer model that can achieve non-random performance on Path-X and Path-256. Path-256 requires longer sequences but has relatively shorter paths than Path-X, so it is easier to obtain a higher accuracy.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;benchmarking-attention&#34;&gt;Benchmarking Attention&lt;/h3&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-9.png&#34; data-caption=&#34;Left - runtime of forward pass &amp;#43; backward pass. Right - attention memory usage&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2023-03-26_flash-attention/images/res-9.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    &lt;strong&gt;Left&lt;/strong&gt; - runtime of forward pass + backward pass. &lt;strong&gt;Right&lt;/strong&gt; - attention memory usage
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;runtime&#34;&gt;Runtime&lt;/h4&gt;
&lt;p&gt;FlashAttention beats all exact attention baselines and is about 3× faster than the PyTorch implementation. The runtimes of many approximate/sparse attention mechanisms grow linearly with sequence length, but FlashAttention still runs faster than approximate and sparse attention for short sequences due to fewer memory accesses. The approximate attention runtimes begin to cross over with FlashAttention at sequences between 512 and 1024. On the other hand, block-sparse FlashAttention is faster than all implementations of exact, sparse, and approximate attention that are available, across all sequence lengths.&lt;/p&gt;
&lt;h4 id=&#34;memory-footprint&#34;&gt;Memory Footprint&lt;/h4&gt;
&lt;p&gt;FlashAttention and block-sparse FlashAttention have the same memory footprint, which grows linearly with sequence length. FlashAttention is up to 20× more memory efficient than exact attention baselines, and is more memory-efficient than the approximate attention baselines.  All other algorithms except for Linformer run out of memory on an A100 GPU before 64K, and FlashAttention is still 2× more efficient than Linformer.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A great paper overall, tremendous impact and personally, I had loads to learn from it!&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js&#34; data-dojo-config=&#34;usePlainJson: true, isDebug: false&#34;&gt;&lt;/script&gt;
&lt;!-- &lt;button style=&#34;background-color: #70ab17; color: #1770AB&#34; id=&#34;openpopup&#34;&gt;Subscribe to my posts!&lt;/button&gt; --&gt;
&lt;div class=&#34;button_cont&#34; align=&#34;center&#34;&gt;&lt;button id=&#34;openpopup&#34; class=&#34;example_a&#34;&gt;Subscribe to my posts!&lt;/button&gt;&lt;/div&gt;
&lt;style&gt;
    .example_a {
        color: #fff !important;
        text-transform: uppercase;
        text-decoration: none;
        background: #3f51b5;
        padding: 20px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        border: none;
        transition: all 0.4s ease 0s;
    }

    .example_a:hover {
        background: #434343;
        letter-spacing: 1px;
        -webkit-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        -moz-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        box-shadow: 5px 40px -10px rgba(0,0,0,0.57);
        transition: all 0.4s ease 0s;
    }
&lt;/style&gt;
&lt;script type=&#34;text/javascript&#34;&gt;

function showMailingPopUp() {
    window.dojoRequire([&#34;mojo/signup-forms/Loader&#34;], function(L) { L.start({&#34;baseUrl&#34;:&#34;mc.us4.list-manage.com&#34;,&#34;uuid&#34;:&#34;0b10ac14f50d7f4e7d11cf26a&#34;,&#34;lid&#34;:&#34;667a1bb3da&#34;,&#34;uniqueMethods&#34;:true}) })

    document.cookie = &#34;MCPopupClosed=;path=/;expires=Thu, 01 Jan 1970 00:00:00 UTC&#34;;
}

document.getElementById(&#34;openpopup&#34;).onclick = function() {showMailingPopUp()};

&lt;/script&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Follow me on &lt;a href=&#34;https://twitter.com/shreyansh_26&#34;&gt;Twitter&lt;/a&gt;, &lt;a href=&#34;https://github.com/shreyansh26&#34;&gt;Github&lt;/a&gt; or connect on &lt;a href=&#34;https://www.linkedin.com/in/shreyansh26/&#34;&gt;LinkedIn&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Summary #7 - Efficient Transformers: A Survey</title>
      <link>https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/</link>
      <pubDate>Mon, 10 Oct 2022 14:57:33 +0530</pubDate>
      <guid>https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Paper&lt;/strong&gt;: Efficient Transformers: A Survey&lt;br&gt;
&lt;strong&gt;Link&lt;/strong&gt;: &lt;a href=&#34;https://arxiv.org/abs/2009.06732&#34;&gt;https://arxiv.org/abs/2009.06732&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;Authors&lt;/strong&gt;: Yi Tay, Mostafa Dehghani, Dara Bahri, Donald Metzler&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;I wanted to summarize this paper for a long time now because of the immense amount of information in this paper. Thanks to the &lt;a href=&#34;https://cohere.for.ai/&#34;&gt;Cohere For AI&lt;/a&gt; community for having a session on this paper which made me revisit this.&lt;/p&gt;
&lt;h1 id=&#34;what&#34;&gt;What?&lt;/h1&gt;
&lt;p&gt;This is a survey paper on the various memory-efficiency based improvements on the original Transformers architecture by Vaswani et al. But wait, for those unaware, how is the Transformers architecture inefficient?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The attention operation has a quadratic complexity over the sequence length L, also sometimes represented using N (since each token attends to other set of tokens in the sequence)&lt;/li&gt;
&lt;li&gt;The Attention operation of Q*K&lt;sup&gt;T&lt;/sup&gt; uses N&lt;sup&gt;2&lt;/sup&gt; time and memory. Here (in no-batching case) Q, K, V (query, key and value matrices) have dimensions &lt;i&gt;N x d &lt;/i&gt; where d is the dimension of query, key and value vectors.&lt;/li&gt;
&lt;/ul&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/attention.PNG&#34; data-caption=&#34;Attention calculation&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/attention.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Attention calculation
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h1 id=&#34;glossary&#34;&gt;Glossary&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#low-rank-methods&#34;&gt;Low-rank Methods&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#linformer---httpsarxivorgabs200604768httpsarxivorgabs200604768&#34;&gt;Linformer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#performer---httpsarxivorgabs200914794httpsarxivorgabs200914794&#34;&gt;Perfomer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#learnable-patterns&#34;&gt;Learnable Patterns based methods&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#clustered-attention---httpsarxivorgabs200704825httpsarxivorgabs200704825--httpsclustered-transformersgithubiobloghttpsclustered-transformersgithubioblog&#34;&gt;Clustered Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reformer---httpsarxivorgabs200104451httpsarxivorgabs200104451&#34;&gt;Reformer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#memory-based&#34;&gt;Memory-based methods&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#big-bird-httpsarxivorgabs200714062httpsarxivorgabs200714062--httpshuggingfacecoblogbig-birdhttpshuggingfacecoblogbig-bird&#34;&gt;Big Bird&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#complexity-summary-of-various-models&#34;&gt;Complexity summary of various models&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;memory-efficient-transformers&#34;&gt;Memory-Efficient Transformers&lt;/h1&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/arch-vaswani.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/arch-vaswani.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/summary.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/summary.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;low-rank-methods&#34;&gt;Low-Rank methods&lt;/h2&gt;
&lt;h3 id=&#34;linformer---httpsarxivorgabs200604768httpsarxivorgabs200604768&#34;&gt;Linformer - &lt;a href=&#34;https://arxiv.org/abs/2006.04768&#34;&gt;https://arxiv.org/abs/2006.04768&lt;/a&gt;&lt;/h3&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/linformer.png&#34; data-caption=&#34;Left and bottom-right show architecture and example of our proposed multihead linear self-attention. Top right shows inference time vs. sequence length for various Linformer models.&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/linformer.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Left and bottom-right show architecture and example of our proposed multihead linear self-attention. Top right shows inference time vs. sequence length for various Linformer models.
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;In Linformer, the original Key and Value matrices are projected from &lt;i&gt;(N x d)&lt;/i&gt; to a reduced &lt;i&gt;(k x d)&lt;/i&gt;.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/linformer-dets.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/linformer-dets.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;The above operations only require &lt;code&gt;O(n*k)&lt;/code&gt; time and space complexity. Thus, if we can choose a very small projected dimension k, such that k &amp;lt; &amp;lt; N, then we can significantly reduce the memory and space consumption.&lt;/p&gt;
&lt;h3 id=&#34;performer---httpsarxivorgabs200914794httpsarxivorgabs200914794&#34;&gt;Performer - &lt;a href=&#34;https://arxiv.org/abs/2009.14794&#34;&gt;https://arxiv.org/abs/2009.14794&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The goal in the Performer paper was to reduce the complexity of attention calculation (Q * K&lt;sup&gt;T&lt;/sup&gt;) * V of O(L&lt;sup&gt;2&lt;/sup&gt; * d) to O (L * d&lt;sup&gt;2&lt;/sup&gt;) by transforming the order of operations and using a kernel operation to approximate the softmax operation so that the order of operations can be changed.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer.png&#34; data-caption=&#34;An overview from the paper&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    An overview from the paper
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;From, a &lt;a href=&#34;https://chiaracampagnola.io/2020/10/29/from-transformers-to-performers/&#34;&gt;great blog on the Performer paper&lt;/a&gt; -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer-dets.png&#34; data-caption=&#34;Change of operation order&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer-dets.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Change of operation order
  &lt;/figcaption&gt;


&lt;/figure&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer-dets2.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer-dets2.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer-dets3.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/performer-dets3.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;h2 id=&#34;learnable-patterns&#34;&gt;Learnable Patterns&lt;/h2&gt;
&lt;h3 id=&#34;clustered-attention---httpsarxivorgabs200704825httpsarxivorgabs200704825--httpsclustered-transformersgithubiobloghttpsclustered-transformersgithubioblog&#34;&gt;Clustered Attention - &lt;a href=&#34;https://arxiv.org/abs/2007.04825&#34;&gt;https://arxiv.org/abs/2007.04825&lt;/a&gt; + &lt;a href=&#34;https://clustered-transformers.github.io/blog/&#34;&gt;https://clustered-transformers.github.io/blog/&lt;/a&gt;&lt;/h3&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/clusteredatt.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/clusteredatt.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;First cluster the queries into  non-overlapping clusters.&lt;/li&gt;
&lt;li&gt;Attention weights A&lt;sup&gt;c&lt;/sup&gt; are computed using the centroids instead of computing them for every query&lt;/li&gt;
&lt;li&gt;Use clustered attention weights A&lt;sup&gt;c&lt;/sup&gt; to compute new Values V&lt;sup&gt;c&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;Use the same attention weights and new values for queries that belong to same cluster.&lt;/li&gt;
&lt;li&gt;Computational complexity becomes &lt;code&gt;O(N * C * max (D&lt;sub&gt;k&lt;/sub&gt; * D&lt;sub&gt;v&lt;/sub&gt;))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;They also propose an Improved Clustered Attention in their blog. The complexity comaprisons are here -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/clusteredatt-dets.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/clusteredatt-dets.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;h3 id=&#34;reformer---httpsarxivorgabs200104451httpsarxivorgabs200104451&#34;&gt;Reformer - &lt;a href=&#34;https://arxiv.org/abs/2001.04451&#34;&gt;https://arxiv.org/abs/2001.04451&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Uses the concept of Locality sensitive hashing (LSH) attention, where the goal is to not store the entire Q * K&lt;sup&gt;T&lt;/sup&gt; matrix but only the softmax(Q * K&lt;sup&gt;T&lt;/sup&gt;), which is dominated by the largest elements in a typically sparse matrix. For each query q we only need to pay attention to the keys k that are closest to q. For example, if K is of length 64K, for each q we could only consider a small subset of the 32 or 64 closest keys. So the attention mechanism finds the nearest neighbor keys of a query but in an inefficient manner.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/reformer-lsh.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/reformer-lsh.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Calcluate LSH hashes of Queries and Keys (Q and K)&lt;/li&gt;
&lt;li&gt;Make chunks and compute attention only for vectors in the same bucket&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The paper also introduces the concept of Reversible residual networks (RevNets). In the residual connections in Transformers, one needs to store the activations in each layer in memory in order to calculate gradients during backpropagation. RevNets are composed of a series of reversible blocks. In RevNet, each layer’s activations can be reconstructed exactly from the subsequent layer’s activations, which enables us to perform backpropagation without storing the activations in memory.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/reformer-revnet.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/reformer-revnet.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;Reformer applies the RevNet idea to the Transformer by combining the attention and feed-forward layers inside the RevNet block. Now F becomes an attention layer and G becomes the feed-forward layer:&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/reformer-revnet2.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/reformer-revnet2.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;The reversible residual layers allows storing activations only once during the training process instead of N times.&lt;/p&gt;
&lt;p&gt;The memory complexity of Reformer is &lt;code&gt;O(N log N)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;memory-based&#34;&gt;Memory-based&lt;/h2&gt;
&lt;h3 id=&#34;big-bird-httpsarxivorgabs200714062httpsarxivorgabs200714062--httpshuggingfacecoblogbig-birdhttpshuggingfacecoblogbig-bird&#34;&gt;Big Bird &lt;a href=&#34;https://arxiv.org/abs/2007.14062&#34;&gt;https://arxiv.org/abs/2007.14062&lt;/a&gt; + &lt;a href=&#34;https://huggingface.co/blog/big-bird&#34;&gt;https://huggingface.co/blog/big-bird&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;BigBird relies on block sparse attention and can handle sequences up to a length of 4096 at a much lower computational cost compared to BERT. It has achieved SOTA on various tasks involving very long sequences such as long documents summarization, question-answering with long contexts.&lt;/p&gt;
&lt;p&gt;BigBird proposes three ways of allowing long-term attention dependencies while staying computationally efficient -&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Global attention&lt;/strong&gt; - Introduce some tokens which will attend to every token and which are attended by every token. The authors call this the &amp;lsquo;internal transformer construction (ITC)&amp;rsquo; in which a subset of indices is selected as global tokens. This can be interpreted as a model-memory-based approach.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sliding attention&lt;/strong&gt; - Tokens close to each other, attend together. In BigBird, each query attends to w/2 tokens to the left and w/2 tokens to the right. This corresponds to a fixed pattern (FP) approach.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Random attention&lt;/strong&gt; - Select some tokens randomly which will transfer information by transferring to other tokens which in turn can transfer to other tokens. This may reduce the cost of information travel from one token to other. Each query attends to r random keys. This pattern is fixed&lt;/li&gt;
&lt;/ul&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/bigbird-graph.gif&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/bigbird-graph.gif&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;BigBird block sparse attention is a combination of sliding, global &amp;amp; random connections (total 10 connections) as shown in gif above. While a graph of normal attention (bottom) will have all 15 connections (note: total 6 nodes are present). One can simply think of normal attention as all the tokens attending globally.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/bigbird-full.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/bigbird-full.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;The attention calculation in BigBird is slightly complex and I would refer to the &lt;a href=&#34;https://huggingface.co/blog/big-bird#bigbird-block-sparse-attention&#34;&gt;Huggingface blog&lt;/a&gt; for it -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/bigbird-attention-gif.gif&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/bigbird-attention-gif.gif&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;p&gt;&lt;i&gt;blue -&amp;gt; global blocks, red -&amp;gt; random blocks, orange -&amp;gt; sliding blocks&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;The memory complexity of the self-attention is linear, i.e., &lt;code&gt;O(n)&lt;/code&gt;. The BigBird model does not introduce new parameters beyond the Transformer model.&lt;/p&gt;
&lt;h2 id=&#34;complexity-summary-of-various-models&#34;&gt;Complexity Summary of various models&lt;/h2&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/complexity-summary.png&#34; &gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2022-10-10_efficient_transformers_survey/images/complexity-summary.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;There are many more papers discussed in the survey. I will add their summaries here as I go through them.&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js&#34; data-dojo-config=&#34;usePlainJson: true, isDebug: false&#34;&gt;&lt;/script&gt;
&lt;!-- &lt;button style=&#34;background-color: #70ab17; color: #1770AB&#34; id=&#34;openpopup&#34;&gt;Subscribe to my posts!&lt;/button&gt; --&gt;
&lt;div class=&#34;button_cont&#34; align=&#34;center&#34;&gt;&lt;button id=&#34;openpopup&#34; class=&#34;example_a&#34;&gt;Subscribe to my posts!&lt;/button&gt;&lt;/div&gt;
&lt;style&gt;
    .example_a {
        color: #fff !important;
        text-transform: uppercase;
        text-decoration: none;
        background: #3f51b5;
        padding: 20px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        border: none;
        transition: all 0.4s ease 0s;
    }

    .example_a:hover {
        background: #434343;
        letter-spacing: 1px;
        -webkit-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        -moz-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        box-shadow: 5px 40px -10px rgba(0,0,0,0.57);
        transition: all 0.4s ease 0s;
    }
&lt;/style&gt;
&lt;script type=&#34;text/javascript&#34;&gt;

function showMailingPopUp() {
    window.dojoRequire([&#34;mojo/signup-forms/Loader&#34;], function(L) { L.start({&#34;baseUrl&#34;:&#34;mc.us4.list-manage.com&#34;,&#34;uuid&#34;:&#34;0b10ac14f50d7f4e7d11cf26a&#34;,&#34;lid&#34;:&#34;667a1bb3da&#34;,&#34;uniqueMethods&#34;:true}) })

    document.cookie = &#34;MCPopupClosed=;path=/;expires=Thu, 01 Jan 1970 00:00:00 UTC&#34;;
}

document.getElementById(&#34;openpopup&#34;).onclick = function() {showMailingPopUp()};

&lt;/script&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;Follow me on &lt;a href=&#34;https://twitter.com/shreyansh_26&#34;&gt;Twitter&lt;/a&gt;, &lt;a href=&#34;https://github.com/shreyansh26&#34;&gt;Github&lt;/a&gt; or connect on &lt;a href=&#34;https://www.linkedin.com/in/shreyansh26/&#34;&gt;LinkedIn&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paper Summary #1 - Attention Is All You Need</title>
      <link>https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/</link>
      <pubDate>Sun, 18 Apr 2021 16:57:49 +0530</pubDate>
      <guid>https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Paper&lt;/strong&gt;: Attention Is All You Need&lt;br&gt;
&lt;strong&gt;Link&lt;/strong&gt;: &lt;a href=&#34;https://bit.ly/3aklLFY&#34;&gt;https://bit.ly/3aklLFY&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;Authors&lt;/strong&gt;: Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, Illia Polosukhin&lt;br&gt;
&lt;strong&gt;Code&lt;/strong&gt;: &lt;a href=&#34;https://github.com/tensorflow/tensor2tensor&#34;&gt;https://github.com/tensorflow/tensor2tensor&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;what&#34;&gt;What?&lt;/h2&gt;
&lt;p&gt;Proposes Transformers, a new simple architecture for sequence transduction that uses only an attention mechanism and does not use any kind of recurrence or convolution. This model achieves SOTA (at the time) on the WMT 2014 English-to-French translation task with a score of 41.0 BLEU. Also beats the existing best results on the WMT 2014 English-to-German translation task with a score of 28.4 BLEU. The training cost is also much less than the best models chosen in the paper (at the time).&lt;/p&gt;
&lt;h2 id=&#34;why&#34;&gt;Why?&lt;/h2&gt;
&lt;p&gt;Existing recurrent models like RNNs, LSTMs or GRUs work sequentially. They align the positions to steps in computation time. They generate a sequence of hidden states as a function of the previous hidden state and the input for the current position. But sequential computation has constraints. They are not easily parallelizable which is required when the sequence lengths become large. The Transformer model eschews recurrence and allows for more parallelization and requires less training time to achieve SOTA in the machine translation task.&lt;/p&gt;
&lt;h2 id=&#34;how&#34;&gt;How?&lt;/h2&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/arch.PNG&#34; data-caption=&#34;Detailed Transformer Architecture&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/arch.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Detailed Transformer Architecture
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;The model is auto-regressive, it consumes the previously generated symbols as additional input when generating the next.&lt;/p&gt;
&lt;h3 id=&#34;encoder&#34;&gt;Encoder&lt;/h3&gt;
&lt;p&gt;The figure above shows just one layer of the encoder on the left. There are &lt;code&gt;N=6&lt;/code&gt; such layers. Each layer has two sub-layers - a multi-head self-attention layer and a position-wise fully connected feed-forward network. &lt;a href=&#34;https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/He_Deep_Residual_Learning_CVPR_2016_paper.pdf&#34;&gt;Residual connections&lt;/a&gt; and &lt;a href=&#34;https://arxiv.org/abs/1607.06450&#34;&gt;layer normalization&lt;/a&gt; is used for each sub-layer.&lt;/p&gt;
&lt;h3 id=&#34;decoder&#34;&gt;Decoder&lt;/h3&gt;
&lt;p&gt;This also has &lt;code&gt;N=6&lt;/code&gt; stacked layers. The architecture diagram shows one layer of the decoder on the right. Each layer has three sub-layers. Two of them are the same as the encoder. The third layer performs multi-head attention over the output of the encoder stack. This is modified to prevent positions from attending to subsequent positions. Additionally, the output embeddings are also offset by one position. These features ensure that the predictions for a position depend only on the known outputs for positions before it.&lt;/p&gt;
&lt;h3 id=&#34;attention&#34;&gt;Attention&lt;/h3&gt;
&lt;p&gt;The paper uses a modified dot product attention, and it is called &amp;ldquo;Scaled Dot Product Attention&amp;rdquo;. Given queries and keys of dimension d&lt;sub&gt;k&lt;/sub&gt; and values of dimension d&lt;sub&gt;v&lt;/sub&gt;, the attention matrix is calculated as shown below.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/attention.PNG&#34; data-caption=&#34;Attention Matrix Calculation&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/attention.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Attention Matrix Calculation
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;Since, for large values of d&lt;sub&gt;k&lt;/sub&gt; the dot product grows large in magnitude, it pushes the softmax function into regions where it has extremely small gradients. The scaling of 1/sqrt(d&lt;sub&gt;k&lt;/sub&gt;) is done to avoid the problem of vanishing gradients.&lt;/p&gt;
&lt;p&gt;Multi-Head attention allows computing this attention in parallel. This helps to focus on different positions. Secondly, it also helps to attend to information from different subspaces due to the more number of attention heads.&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/multihead-attention.PNG&#34; data-caption=&#34;Multihead Attention Calculation&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/multihead-attention.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Multihead Attention Calculation
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;The paper uses &lt;code&gt;h=8&lt;/code&gt; parallel attention layers or heads. The reduced dimension of each head compensates for the more number of heads and hence the computational cost remains the same as with single-head attention with full dimensionality.&lt;/p&gt;
&lt;p&gt;Applications of multi-head attention in the paper are given below -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/application-attention.PNG&#34; data-caption=&#34;Application of multi-head attention in the model&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/application-attention.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Application of multi-head attention in the model
  &lt;/figcaption&gt;


&lt;/figure&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/multihead-attention-fig.PNG&#34; data-caption=&#34;Pictorial representaion of Multi-head attention&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/multihead-attention-fig.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Pictorial representaion of Multi-head attention
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;h3 id=&#34;position-wise-feed-forward-networks&#34;&gt;Position-wise Feed-Forward Networks&lt;/h3&gt;
&lt;p&gt;The FFN sub-layer shown in the encoder and decoder architecture is a 2-hidden layer FC FNN with a ReLU activation in between.&lt;/p&gt;
&lt;h3 id=&#34;positional-encodings&#34;&gt;Positional Encodings&lt;/h3&gt;
&lt;p&gt;Positional encodings are injected (added) to the input embeddings at the bottom of the encoder and decoder stack to add some information about the relative order of the tokens in the sequence. The positional encodings have the same dimension as the input embeddings so that they can be added.
For position &lt;em&gt;pos&lt;/em&gt; and dimension &lt;em&gt;i&lt;/em&gt; the paper uses the following positional embeddings -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/positional.PNG&#34; data-caption=&#34;Positional Encoding calculation&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/positional.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Positional Encoding calculation
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;p&gt;This choice allows the model to easily learn by the relative positions. The learned positional embeddings also perform about the same as the sinusoidal version. The sinusoidal version may allow the model to extrapolate to sequence lengths longer than the ones encountered in training.&lt;/p&gt;
&lt;h2 id=&#34;results&#34;&gt;Results&lt;/h2&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/experiments.PNG&#34; data-caption=&#34;Experimental results when varying parameters&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/experiments.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Experimental results when varying parameters
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Form (A), it can be seen that single-head attention is slightly worse than the best setting. The quality also drops off with too many heads.&lt;/li&gt;
&lt;li&gt;(B) shows that reducing the attention key size &lt;i&gt;d&lt;sub&gt;k&lt;/sub&gt;&lt;/i&gt; hurts model quality.&lt;/li&gt;
&lt;li&gt;In (C) and (D), it is visible that bigger models are better and dropout helps in avoiding overfitting.&lt;/li&gt;
&lt;li&gt;(E) shows that sinusoidal positional encoding when replaced with learned positional embeddings also does not lead to a loss in quality&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the base models, the authors used a single model obtained by averaging the last 5 checkpoints, which were written at 10-minute intervals. The big models were averaged over the last 20 checkpoints. Beam search with a beam size of 4 and length penalty α = 0.6. The maximum output length during inference is set to input length +50, but if it is possible, the model terminates early.&lt;/p&gt;
&lt;p&gt;The performance comparison with the other models is shown below -&lt;/p&gt;













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/results.PNG&#34; data-caption=&#34;Model performance&#34;&gt;
&lt;img src=&#34;https://shreyansh26.github.io/post/2021-04-18_attention_is_all_you_need/images/results.PNG&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Model performance
  &lt;/figcaption&gt;


&lt;/figure&gt;

&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;I have also released an annotated version of the paper. If you are interested, you can find it &lt;a href=&#34;https://github.com/shreyansh26/Annotated-ML-Papers/blob/main/Attention%20Is%20All%20You%20Need.pdf&#34;&gt;here&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This is all for now!&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js&#34; data-dojo-config=&#34;usePlainJson: true, isDebug: false&#34;&gt;&lt;/script&gt;
&lt;!-- &lt;button style=&#34;background-color: #70ab17; color: #1770AB&#34; id=&#34;openpopup&#34;&gt;Subscribe to my posts!&lt;/button&gt; --&gt;
&lt;div class=&#34;button_cont&#34; align=&#34;center&#34;&gt;&lt;button id=&#34;openpopup&#34; class=&#34;example_a&#34;&gt;Subscribe to my posts!&lt;/button&gt;&lt;/div&gt;
&lt;style&gt;
    .example_a {
        color: #fff !important;
        text-transform: uppercase;
        text-decoration: none;
        background: #3f51b5;
        padding: 20px;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
        border: none;
        transition: all 0.4s ease 0s;
    }

    .example_a:hover {
        background: #434343;
        letter-spacing: 1px;
        -webkit-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        -moz-box-shadow: 0px 5px 40px -10px rgba(0,0,0,0.57);
        box-shadow: 5px 40px -10px rgba(0,0,0,0.57);
        transition: all 0.4s ease 0s;
    }
&lt;/style&gt;
&lt;script type=&#34;text/javascript&#34;&gt;

function showMailingPopUp() {
    window.dojoRequire([&#34;mojo/signup-forms/Loader&#34;], function(L) { L.start({&#34;baseUrl&#34;:&#34;mc.us4.list-manage.com&#34;,&#34;uuid&#34;:&#34;0b10ac14f50d7f4e7d11cf26a&#34;,&#34;lid&#34;:&#34;667a1bb3da&#34;,&#34;uniqueMethods&#34;:true}) })

    document.cookie = &#34;MCPopupClosed=;path=/;expires=Thu, 01 Jan 1970 00:00:00 UTC&#34;;
}

document.getElementById(&#34;openpopup&#34;).onclick = function() {showMailingPopUp()};

&lt;/script&gt;
&lt;p&gt; &lt;/p&gt;
&lt;script data-name=&#34;BMC-Widget&#34; data-cfasync=&#34;false&#34; src=&#34;https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js&#34; data-id=&#34;shreyanshsingh&#34; data-description=&#34;Support me on Buy me a coffee!&#34; data-message=&#34;&#34; data-color=&#34;#FF5F5F&#34; data-position=&#34;Right&#34; data-x_margin=&#34;18&#34; data-y_margin=&#34;18&#34;&gt;&lt;/script&gt;
&lt;p&gt;Follow me on &lt;a href=&#34;https://twitter.com/shreyansh_26&#34;&gt;Twitter&lt;/a&gt;, &lt;a href=&#34;https://github.com/shreyansh26&#34;&gt;Github&lt;/a&gt; or connect on &lt;a href=&#34;https://www.linkedin.com/in/shreyansh26/&#34;&gt;LinkedIn&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
